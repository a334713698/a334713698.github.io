<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
    
  <meta name="description" content="iOS coder,Machine-learning,DJ Hong的个人博客" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     GG266的个人博客
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/favicon.jpg" />
  
  <link rel="stylesheet" href="/css/style.css">
  <script src="/js/pace.min.js"></script>

  

  

</head>

</html>

<body>
  <div id="app">
    <main class="content">
      
<div id="main">
  <section class="outer">
  <article class="articles">
    
    
    
    
    <article id="post-iOS源码阅读 —— MJExtension" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/09/09/iOS源码阅读 —— MJExtension/"
    >iOS源码阅读 —— MJExtension</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/09/09/iOS源码阅读 —— MJExtension/" class="article-date">
  <time datetime="2020-09-09T12:28:59.000Z" itemprop="datePublished">2020-09-09</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

      
      
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>MJExtension是一款开源的，简单易用的字典与模型转换框架。<br>常用的方法，主要是以下几个：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// JSON|字典 转 模型</span><br><span class="line">+ (instancetype)mj_objectWithKeyValues:(id)keyValues;</span><br><span class="line"></span><br><span class="line">// 通过 JSON|字典 为 模型赋值</span><br><span class="line">- (instancetype)mj_setKeyValues:(id)keyValues;</span><br><span class="line"></span><br><span class="line">// 模型转JSON</span><br><span class="line">- (NSMutableDictionary *)mj_keyValues;</span><br><span class="line"></span><br><span class="line">// JSON数组转模型数组</span><br><span class="line">+ (NSMutableArray *)mj_objectArrayWithKeyValuesArray:(id)keyValuesArray;</span><br></pre></td></tr></table></figure></p>
<h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><h2 id="JSON-字典-转-模型"><a href="#JSON-字典-转-模型" class="headerlink" title="JSON|字典 转 模型"></a>JSON|字典 转 模型</h2><h3 id="mj-objectWithKeyValues"><a href="#mj-objectWithKeyValues" class="headerlink" title="+ mj_objectWithKeyValues:"></a>+ mj_objectWithKeyValues:</h3><p><code>+ mj_objectWithKeyValues:</code> 是框架中最简单的JSON转模型的方法，通过直接调用类方法并传入JSON数据即可快速实现转换。而在<code>+ mj_objectWithKeyValues:</code>方法中，实际是调用了<code>+ mj_objectWithKeyValues: context:</code>方法，参数中如果传了<code>contenxt</code>，最终会返回CoreData模型；如果不传，返回已赋值的模型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)mj_objectWithKeyValues:(id)keyValues context:(NSManagedObjectContext *)context</span><br><span class="line">&#123;</span><br><span class="line">    // 获得JSON对象</span><br><span class="line">    keyValues = [keyValues mj_JSONObject];</span><br><span class="line">    MJExtensionAssertError([keyValues isKindOfClass:[NSDictionary class]], nil, [self class], @&quot;keyValues参数不是一个字典&quot;);</span><br><span class="line"></span><br><span class="line">    // 判断是否传入 &quot;contenxt&quot; 参数</span><br><span class="line">    if ([self isSubclassOfClass:[NSManagedObject class]] &amp;&amp; context) &#123;</span><br><span class="line">        NSString *entityName = [NSStringFromClass(self) componentsSeparatedByString:@&quot;.&quot;].lastObject;</span><br><span class="line">        return [[NSEntityDescription insertNewObjectForEntityForName:entityName inManagedObjectContext:context] mj_setKeyValues:keyValues context:context];</span><br><span class="line">    &#125;</span><br><span class="line">    return [[[self alloc] init] mj_setKeyValues:keyValues];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在为实例赋值的方法中，由于<code>- mj_setKeyValues:</code>实际的实现是调用<code>- mj_setKeyValues: context:</code>。所以我们直接进入<code>- mj_setKeyValues: context:</code>进行分析。</p>
<p>首先，需要将传入的<code>keyValues</code>处理成可用的JSON对象，并获取当前类的类型，以及黑白名单属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 获得JSON对象</span><br><span class="line">keyValues = [keyValues mj_JSONObject];</span><br><span class="line">MJExtensionAssertError([keyValues isKindOfClass:[NSDictionary class]], self, [self class], @&quot;keyValues参数不是一个字典&quot;);</span><br><span class="line"></span><br><span class="line">Class clazz = [self class];</span><br><span class="line">NSArray *allowedPropertyNames = [clazz mj_totalAllowedPropertyNames];</span><br><span class="line">NSArray *ignoredPropertyNames = [clazz mj_totalIgnoredPropertyNames];</span><br></pre></td></tr></table></figure></p>
<p>紧接着，调用类的扩展方法<code>+ mj_enumerateProperties:</code>，获取和遍历类的属性列表，通过block参数进行回调，在回调的代码块中，对每个属性进行注意赋值。</p>
<p><strong>核心代码：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">//通过封装的方法回调一个通过运行时编写的，用于返回属性列表的方法。</span><br><span class="line">[clazz mj_enumerateProperties:^(MJProperty *property, BOOL *stop) &#123;</span><br><span class="line">    @try &#123;</span><br><span class="line">        // 0.检测是否被忽略</span><br><span class="line">        if (allowedPropertyNames.count &amp;&amp; ![allowedPropertyNames containsObject:property.name]) return;</span><br><span class="line">        if ([ignoredPropertyNames containsObject:property.name]) return;</span><br><span class="line"></span><br><span class="line">        // 1.取出属性值</span><br><span class="line">        id value;</span><br><span class="line">        NSArray *propertyKeyses = [property propertyKeysForClass:clazz];</span><br><span class="line">        for (NSArray *propertyKeys in propertyKeyses) &#123;</span><br><span class="line">            value = keyValues;</span><br><span class="line">            for (MJPropertyKey *propertyKey in propertyKeys) &#123;</span><br><span class="line">                value = [propertyKey valueInObject:value];</span><br><span class="line">            &#125;</span><br><span class="line">            if (value) break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 值的过滤</span><br><span class="line">        id newValue = [clazz mj_getNewValueFromObject:self oldValue:value property:property];</span><br><span class="line">        if (newValue != value) &#123; // 有过滤后的新值</span><br><span class="line">            [property setValue:newValue forObject:self];</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 如果没有值，就直接返回</span><br><span class="line">        if (!value || value == [NSNull null]) return;</span><br><span class="line"></span><br><span class="line">        // 2.复杂处理</span><br><span class="line">        MJPropertyType *type = property.type; // 数据类型类</span><br><span class="line">        Class propertyClass = type.typeClass; // 对象类型</span><br><span class="line">        Class objectClass = [property objectClassInArrayForClass:[self class]]; // 数组中的模型类型</span><br><span class="line"></span><br><span class="line">        // 不可变 -&gt; 可变处理</span><br><span class="line">        if (propertyClass == [NSMutableArray class] &amp;&amp; [value isKindOfClass:[NSArray class]]) &#123;</span><br><span class="line">            value = [NSMutableArray arrayWithArray:value];</span><br><span class="line">        &#125; else if (propertyClass == [NSMutableDictionary class] &amp;&amp; [value isKindOfClass:[NSDictionary class]]) &#123;</span><br><span class="line">            value = [NSMutableDictionary dictionaryWithDictionary:value];</span><br><span class="line">        &#125; else if (propertyClass == [NSMutableString class] &amp;&amp; [value isKindOfClass:[NSString class]]) &#123;</span><br><span class="line">            value = [NSMutableString stringWithString:value];</span><br><span class="line">        &#125; else if (propertyClass == [NSMutableData class] &amp;&amp; [value isKindOfClass:[NSData class]]) &#123;</span><br><span class="line">            value = [NSMutableData dataWithData:value];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!type.isFromFoundation &amp;&amp; propertyClass) &#123; // 模型属性</span><br><span class="line">            // 既不是基础类型，也不是NS类型。即：基本数据类型</span><br><span class="line">            value = [propertyClass mj_objectWithKeyValues:value context:context];</span><br><span class="line">        &#125; else if (objectClass) &#123;</span><br><span class="line">            if (objectClass == [NSURL class] &amp;&amp; [value isKindOfClass:[NSArray class]]) &#123;</span><br><span class="line">                // string array -&gt; url array</span><br><span class="line">                NSMutableArray *urlArray = [NSMutableArray array];</span><br><span class="line">                for (NSString *string in value) &#123;</span><br><span class="line">                    if (![string isKindOfClass:[NSString class]]) continue;</span><br><span class="line">                    [urlArray addObject:string.mj_url];</span><br><span class="line">                &#125;</span><br><span class="line">                value = urlArray;</span><br><span class="line">            &#125; else &#123; // 字典数组--&gt;模型数组</span><br><span class="line">                value = [objectClass mj_objectArrayWithKeyValuesArray:value context:context];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (propertyClass == [NSString class]) &#123;</span><br><span class="line">            if ([value isKindOfClass:[NSNumber class]]) &#123;</span><br><span class="line">                // NSNumber -&gt; NSString</span><br><span class="line">                value = [value description];</span><br><span class="line">            &#125; else if ([value isKindOfClass:[NSURL class]]) &#123;</span><br><span class="line">                // NSURL -&gt; NSString</span><br><span class="line">                value = [value absoluteString];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if ([value isKindOfClass:[NSString class]]) &#123;</span><br><span class="line">            if (propertyClass == [NSURL class]) &#123;</span><br><span class="line">                // NSString -&gt; NSURL</span><br><span class="line">                // 字符串转码</span><br><span class="line">                value = [value mj_url];</span><br><span class="line">            &#125; else if (type.isNumberType) &#123;</span><br><span class="line">                NSString *oldValue = value;</span><br><span class="line"></span><br><span class="line">                // NSString -&gt; NSDecimalNumber, 使用 DecimalNumber 来转换数字, 避免丢失精度以及溢出</span><br><span class="line">                NSDecimalNumber *decimalValue = [NSDecimalNumber decimalNumberWithString:oldValue</span><br><span class="line">                                                                                  locale:numberLocale];</span><br><span class="line"></span><br><span class="line">                // 检查特殊情况</span><br><span class="line">                if (decimalValue == NSDecimalNumber.notANumber) &#123;</span><br><span class="line">                    value = @(0);</span><br><span class="line">                &#125;else if (propertyClass != [NSDecimalNumber class]) &#123;</span><br><span class="line">                    value = [decimalValue mj_standardValueWithTypeCode:type.code];</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    value = decimalValue;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // 如果是BOOL</span><br><span class="line">                if (type.isBoolType) &#123;</span><br><span class="line">                    // 字符串转BOOL（字符串没有charValue方法）</span><br><span class="line">                    // 系统会调用字符串的charValue转为BOOL类型</span><br><span class="line">                    NSString *lower = [oldValue lowercaseString];</span><br><span class="line">                    if ([lower isEqualToString:@&quot;yes&quot;] || [lower isEqualToString:@&quot;true&quot;]) &#123;</span><br><span class="line">                        value = @YES;</span><br><span class="line">                    &#125; else if ([lower isEqualToString:@&quot;no&quot;] || [lower isEqualToString:@&quot;false&quot;]) &#123;</span><br><span class="line">                        value = @NO;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if ([value isKindOfClass:[NSNumber class]] &amp;&amp; propertyClass == [NSDecimalNumber class])&#123;</span><br><span class="line">            // 过滤 NSDecimalNumber类型</span><br><span class="line">            if (![value isKindOfClass:[NSDecimalNumber class]]) &#123;</span><br><span class="line">                value = [NSDecimalNumber decimalNumberWithDecimal:[((NSNumber *)value) decimalValue]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 经过转换后, 最终检查 value 与 property 是否匹配</span><br><span class="line">        if (propertyClass &amp;&amp; ![value isKindOfClass:propertyClass]) &#123;</span><br><span class="line">            value = nil;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 3.赋值（KVC）</span><br><span class="line">        [property setValue:value forObject:self];</span><br><span class="line">    &#125; @catch (NSException *exception) &#123;</span><br><span class="line">        MJExtensionBuildError([self class], exception.reason);</span><br><span class="line">        MJExtensionLog(@&quot;%@&quot;, exception);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p>
<p>从代码中，可以直观看出，赋值操作主要分为步骤4个步骤。</p>
<h4 id="0-检测是否被忽略"><a href="#0-检测是否被忽略" class="headerlink" title="0.检测是否被忽略"></a>0.检测是否被忽略</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 白名单</span><br><span class="line">if (allowedPropertyNames.count &amp;&amp; ![allowedPropertyNames containsObject:property.name]) return;</span><br><span class="line">// 黑名单</span><br><span class="line">if ([ignoredPropertyNames containsObject:property.name]) return;</span><br></pre></td></tr></table></figure>
<p>判断黑白名单中是否包含相应的属性名称。</p>
<h4 id="1-取出属性值"><a href="#1-取出属性值" class="headerlink" title="1.取出属性值"></a>1.取出属性值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">id value;</span><br><span class="line">NSArray *propertyKeyses = [property propertyKeysForClass:clazz];</span><br><span class="line">for (NSArray *propertyKeys in propertyKeyses) &#123;</span><br><span class="line">    value = keyValues;</span><br><span class="line">    for (MJPropertyKey *propertyKey in propertyKeys) &#123;</span><br><span class="line">        value = [propertyKey valueInObject:value];</span><br><span class="line">    &#125;</span><br><span class="line">    if (value) break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 值的过滤</span><br><span class="line">id newValue = [clazz mj_getNewValueFromObject:self oldValue:value property:property];</span><br><span class="line">if (newValue != value) &#123; // 有过滤后的新值</span><br><span class="line">    [property setValue:newValue forObject:self];</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 如果没有值，就直接返回</span><br><span class="line">if (!value || value == [NSNull null]) return;</span><br></pre></td></tr></table></figure>
<p>因为同一个成员属性，父类和子类的行为可能不一致（originKey、propertyKeys、objectClassInArray），所以其键值可能是一个数组，通过循环这个数组尝试获取值。<br>对值得过滤，指的是使用者通过实现<code>- (id)mj_newValueFromOldValue: property:</code>方法，对结果进行进一步的处理（比如字符串日期处理为NSDate、字符串nil处理为@””）。</p>
<h4 id="2-复杂处理"><a href="#2-复杂处理" class="headerlink" title="2.复杂处理"></a>2.复杂处理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">MJPropertyType *type = property.type; // 数据类型的信息</span><br><span class="line">Class propertyClass = type.typeClass; // 属性的类型</span><br><span class="line">Class objectClass = [property objectClassInArrayForClass:[self class]]; // 数组中模型的类型</span><br><span class="line"></span><br><span class="line">// 不可变 -&gt; 可变处理</span><br><span class="line">if (propertyClass == [NSMutableArray class] &amp;&amp; [value isKindOfClass:[NSArray class]]) &#123;</span><br><span class="line">    value = [NSMutableArray arrayWithArray:value];</span><br><span class="line">&#125; else if (propertyClass == [NSMutableDictionary class] &amp;&amp; [value isKindOfClass:[NSDictionary class]]) &#123;</span><br><span class="line">    value = [NSMutableDictionary dictionaryWithDictionary:value];</span><br><span class="line">&#125; else if (propertyClass == [NSMutableString class] &amp;&amp; [value isKindOfClass:[NSString class]]) &#123;</span><br><span class="line">    value = [NSMutableString stringWithString:value];</span><br><span class="line">&#125; else if (propertyClass == [NSMutableData class] &amp;&amp; [value isKindOfClass:[NSData class]]) &#123;</span><br><span class="line">    value = [NSMutableData dataWithData:value];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (!type.isFromFoundation &amp;&amp; propertyClass) &#123; // 模型属性</span><br><span class="line">    // 既不是基础类型，也不是NS类型。即：基本数据类型</span><br><span class="line">    value = [propertyClass mj_objectWithKeyValues:value context:context];</span><br><span class="line">&#125; else if (objectClass) &#123;</span><br><span class="line">    if (objectClass == [NSURL class] &amp;&amp; [value isKindOfClass:[NSArray class]]) &#123;</span><br><span class="line">        // string array -&gt; url array</span><br><span class="line">        NSMutableArray *urlArray = [NSMutableArray array];</span><br><span class="line">        for (NSString *string in value) &#123;</span><br><span class="line">            if (![string isKindOfClass:[NSString class]]) continue;</span><br><span class="line">            [urlArray addObject:string.mj_url];</span><br><span class="line">        &#125;</span><br><span class="line">        value = urlArray;</span><br><span class="line">    &#125; else &#123; // 字典数组--&gt;模型数组</span><br><span class="line">        value = [objectClass mj_objectArrayWithKeyValuesArray:value context:context];</span><br><span class="line">    &#125;</span><br><span class="line">&#125; else if (propertyClass == [NSString class]) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125; else if ([value isKindOfClass:[NSString class]]) &#123;</span><br><span class="line"></span><br><span class="line">&#125; else if ([value isKindOfClass:[NSNumber class]] &amp;&amp; propertyClass == [NSDecimalNumber class])&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂处理，主要是对属性值的类型进行判断，属性值的类型只要分为：模型属性（自定义类）、数组属性和其他属性（NS类型）。<br>模型属性的value，需要通过继续调用<code>- mj_objectWithKeyValues:value context:</code>方法，将字典转换成模型。<br>数组属性的值，则需要根据数组中模型的类型，进行循环转换。<br>其他情况的值，可以通过简单的转化或者直接使用。</p>
<h4 id="3-赋值"><a href="#3-赋值" class="headerlink" title="3.赋值"></a>3.赋值</h4><p>至此，属性信息和值都有了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 经过转换后, 最终检查 value 与 property 是否匹配</span><br><span class="line">if (propertyClass &amp;&amp; ![value isKindOfClass:propertyClass]) &#123;</span><br><span class="line">    value = nil;</span><br><span class="line">&#125;</span><br><span class="line">[property setValue:value forObject:self];</span><br></pre></td></tr></table></figure></p>
<p>在确定 value的值 与 property得类型 确实匹配后，通过KVC进行赋值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  设置成员变量的值</span><br><span class="line"> */</span><br><span class="line">- (void)setValue:(id)value forObject:(id)object</span><br><span class="line">&#123;</span><br><span class="line">    if (self.type.KVCDisabled || value == nil) return;</span><br><span class="line">    [object setValue:value forKey:self.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>到此，JSON转模型的工作就完成了。</p>
<h2 id="模型-转-JSON-字典"><a href="#模型-转-JSON-字典" class="headerlink" title="模型 转 JSON|字典"></a>模型 转 JSON|字典</h2><h3 id="mj-keyValues"><a href="#mj-keyValues" class="headerlink" title="- mj_keyValues"></a>- mj_keyValues</h3><p>模型转JSON的方法主要有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 转换并返回模型中所有属性的键值对</span><br><span class="line">- (NSMutableDictionary *)mj_keyValues;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> @para keys 需要返回的特定键的数组</span><br><span class="line"> @return 特定关键词的键值对</span><br><span class="line"> */</span><br><span class="line">- (NSMutableDictionary *)mj_keyValuesWithKeys:(NSArray *)keys;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> @para ignoredKeys 需要忽略的特定键的数组</span><br><span class="line"> @return 除特定关键词的其他有效键值对</span><br><span class="line"> */</span><br><span class="line">- (NSMutableDictionary *)mj_keyValuesWithIgnoredKeys:(NSArray *)ignoredKeys;</span><br></pre></td></tr></table></figure></p>
<p>以上方法统一调用了<code>- mj_keyValuesWithKeys:ignoredKeys:</code>，让我们直接进入这个方法一探究竟。<br><code>- mj_keyValuesWithKeys:ignoredKeys:</code>方法与JSON转模型的核心逻辑是极其相似的，即通过遍历类的所有属性，进行相关操作，这里我们直接进入代码块，进行分析。</p>
<h4 id="0-检测是否被忽略-1"><a href="#0-检测是否被忽略-1" class="headerlink" title="0.检测是否被忽略"></a>0.检测是否被忽略</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 白名单</span><br><span class="line">if (allowedPropertyNames.count &amp;&amp; ![allowedPropertyNames containsObject:property.name]) return;</span><br><span class="line">// 黑名单</span><br><span class="line">if ([ignoredPropertyNames containsObject:property.name]) return;</span><br><span class="line">// 只需要返回的特定键</span><br><span class="line">if (keys.count &amp;&amp; ![keys containsObject:property.name]) return;</span><br><span class="line">// 需要被忽略的特定键</span><br><span class="line">if ([ignoredKeys containsObject:property.name]) return;</span><br></pre></td></tr></table></figure>
<p>返回的结果，不仅可以对黑白名单中的属性进行筛选，还可以根据具体场景设置需要返回和忽略的特定键值。</p>
<h4 id="1-取出属性值-1"><a href="#1-取出属性值-1" class="headerlink" title="1.取出属性值"></a>1.取出属性值</h4><p>使用KVC取值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">id value = [property valueForObject:self];</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  获得成员变量的值</span><br><span class="line"> */</span><br><span class="line">- (id)valueForObject:(id)object</span><br><span class="line">&#123;</span><br><span class="line">    if (self.type.KVCDisabled) return [NSNull null];</span><br><span class="line"></span><br><span class="line">    id value = [object valueForKey:self.name];</span><br><span class="line"></span><br><span class="line">    // 32位BOOL类型转换json后成Int类型</span><br><span class="line">    /** https://github.com/CoderMJLee/MJExtension/issues/545 */</span><br><span class="line">    // 32 bit device OR 32 bit Simulator</span><br><span class="line">#if defined(__arm__) || (TARGET_OS_SIMULATOR &amp;&amp; !__LP64__)</span><br><span class="line">    if (self.type.isBoolType) &#123;</span><br><span class="line">        value = @([(NSNumber *)value boolValue]);</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="2-模型属性和数组的处理"><a href="#2-模型属性和数组的处理" class="headerlink" title="2.模型属性和数组的处理"></a>2.模型属性和数组的处理</h4><p>如果当前的属性属于模型类型或数组，则需要对 <code>value</code> 进行递归调用 <code>- mj_keyValues</code> 方法，直至最终得到非模型和非数组的数据类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MJPropertyType *type = property.type;</span><br><span class="line">Class propertyClass = type.typeClass;</span><br><span class="line">if (!type.isFromFoundation &amp;&amp; propertyClass) &#123;</span><br><span class="line">    value = [value mj_keyValues];</span><br><span class="line">&#125; else if ([value isKindOfClass:[NSArray class]]) &#123;</span><br><span class="line">    // 3.处理数组里面有模型的情况</span><br><span class="line">    value = [NSObject mj_keyValuesArrayWithObjectArray:value];</span><br><span class="line">&#125; else if (propertyClass == [NSURL class]) &#123;</span><br><span class="line">    value = [value absoluteString];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="3-赋值-1"><a href="#3-赋值-1" class="headerlink" title="3.赋值"></a>3.赋值</h4><p>在对结果<code>keyValues</code>进行赋值之前，需要先判断创建键值时，是否引用了替换键 —— 也就是在<code>+ mj_replacedKeyFromPropertyName</code>方法中返回的自定义映射表。<br>对于没有引用替换键的值，可以直接赋值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keyValues[property.name] = value;</span><br></pre></td></tr></table></figure></p>
<p>对于引用了替换键的值，需要获取原始的key，最终结果也将返回最原始的JSON或字典。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// 获取原始key</span><br><span class="line">NSArray *propertyKeys = [[property propertyKeysForClass:clazz] firstObject];</span><br><span class="line">NSUInteger keyCount = propertyKeys.count;</span><br><span class="line">// 创建字典</span><br><span class="line">__block id innerContainer = keyValues;</span><br><span class="line">[propertyKeys enumerateObjectsUsingBlock:^(MJPropertyKey *propertyKey, NSUInteger idx, BOOL *stop) &#123;</span><br><span class="line">    // 下一个属性</span><br><span class="line">    MJPropertyKey *nextPropertyKey = nil;</span><br><span class="line">    if (idx != keyCount - 1) &#123;</span><br><span class="line">        nextPropertyKey = propertyKeys[idx + 1];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (nextPropertyKey) &#123; // 不是最后一个key</span><br><span class="line">        // 当前propertyKey对应的字典或者数组</span><br><span class="line">        id tempInnerContainer = [propertyKey valueInObject:innerContainer];</span><br><span class="line">        if (tempInnerContainer == nil || [tempInnerContainer isKindOfClass:[NSNull class]]) &#123;</span><br><span class="line">            if (nextPropertyKey.type == MJPropertyKeyTypeDictionary) &#123;</span><br><span class="line">                tempInnerContainer = [NSMutableDictionary dictionary];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                tempInnerContainer = [NSMutableArray array];</span><br><span class="line">            &#125;</span><br><span class="line">            if (propertyKey.type == MJPropertyKeyTypeDictionary) &#123;</span><br><span class="line">                innerContainer[propertyKey.name] = tempInnerContainer;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                innerContainer[propertyKey.name.intValue] = tempInnerContainer;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if ([tempInnerContainer isKindOfClass:[NSMutableArray class]]) &#123;</span><br><span class="line">            NSMutableArray *tempInnerContainerArray = tempInnerContainer;</span><br><span class="line">            int index = nextPropertyKey.name.intValue;</span><br><span class="line">            while (tempInnerContainerArray.count &lt; index + 1) &#123;</span><br><span class="line">                [tempInnerContainerArray addObject:[NSNull null]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        innerContainer = tempInnerContainer;</span><br><span class="line">    &#125; else &#123; // 最后一个key</span><br><span class="line">        if (propertyKey.type == MJPropertyKeyTypeDictionary) &#123;</span><br><span class="line">            innerContainer[propertyKey.name] = value;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            innerContainer[propertyKey.name.intValue] = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>核心代码：</strong></p>
<ul>
<li>JSON|字典转模型的各类方法，最终都会调用<code>- mj_setKeyValues:(id)keyValues context:</code></li>
<li>模型转JSON|字典的各类方法，最终都会调用<code>- (NSMutableDictionary *)mj_keyValuesWithKeys: ignoredKeys:</code></li>
</ul>
<p><strong>性能方面:</strong></p>
<ul>
<li>使用runtime动态生成类的属性信息，并通过缓存机制进行性能提优。</li>
</ul>
<p><strong>容错方面</strong></p>
<ul>
<li>在JSON|字典转模型最后赋值之前，会对值和属性的类型进行一致性的判断。如果不匹配，<code>value</code>会被置为nil，避免潜在的Crash风险。</li>
</ul>

      
      <!-- 打赏 -->
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/09/09/iOS源码阅读 —— MJExtension/" data-id="ckevd229j001ckdbu6nc7w157"
        class="article-share-link">分享</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MJExtension/">MJExtension</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码阅读/">源码阅读</a></li></ul>

    </footer>

  </div>

  

  

  

</article>
    
    <article id="post-iOS源码阅读——YYModel" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/09/03/iOS源码阅读——YYModel/"
    >iOS源码阅读——YYModel</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/09/03/iOS源码阅读——YYModel/" class="article-date">
  <time datetime="2020-09-03T15:14:23.000Z" itemprop="datePublished">2020-09-03</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

      
      
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>YYModel作为一个 iOS/OSX 模型转换框架，为JSON与数据模型之间的转换，提供了高性能的解决方案。</p>
<p>在我个人的日常开发中，主要使用的方法有以下几个：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// JSON|字典 转 模型</span><br><span class="line">+ (nullable instancetype)yy_modelWithJSON:(id)json;</span><br><span class="line">+ (nullable instancetype)yy_modelWithDictionary:(NSDictionary *)dictionary;</span><br><span class="line"></span><br><span class="line">// 通过 JSON|字典 为 模型赋值</span><br><span class="line">- (BOOL)yy_modelSetWithJSON:(id)json;</span><br><span class="line">- (BOOL)yy_modelSetWithDictionary:(NSDictionary *)dic;</span><br><span class="line"></span><br><span class="line">// 模型转JSON</span><br><span class="line">- (NSString *)yy_modelToJSONString;</span><br><span class="line"></span><br><span class="line">// JSON数组转模型数组</span><br><span class="line">+ (nullable NSArray *)yy_modelArrayWithClass:(Class)cls json:(id)json;</span><br></pre></td></tr></table></figure></p>
<p>由于多个功能，最终调用的方法是相同的，所以这里仅列出主要方法的代码解析。</p>
<h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><h2 id="JSON转模型"><a href="#JSON转模型" class="headerlink" title="JSON转模型"></a>JSON转模型</h2><h3 id="yy-modelWithDictionary"><a href="#yy-modelWithDictionary" class="headerlink" title="+ yy_modelWithDictionary:"></a>+ yy_modelWithDictionary:</h3><p>由于调用<code>+ yy_modelWithJSON:</code>方法时，方法内部先将JSON序列化为可用的字典，然后调用<code>+ yy_modelWithDictionary:</code>方法。所以我们直接进入<code>+ yy_modelWithDictionary:</code>进行分析。</p>
<p><strong>代码：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> 通过一组 键-值对(NSDictionary)，创建和返回一个新的实例</span><br><span class="line"> 此方法是线程安全的。</span><br><span class="line"></span><br><span class="line"> @参数： dictionary  一组能够映射实例属性的 键-值对(dictionary)</span><br><span class="line"> 无效的键值对将会被忽略。</span><br><span class="line"></span><br><span class="line"> @返回： 一个通过 键-值对(dictionary) 创建的新实例，出错的情况下返回nil。</span><br><span class="line"></span><br><span class="line"> @说明： 字典中的 key 和 value 将分别映射在模型的属性名，和属性值上。</span><br><span class="line"> 如果值得类型不发与属性相匹配，此方法将尝试根据如下规则，进行转化：</span><br><span class="line"></span><br><span class="line">     `NSString` or `NSNumber` -&gt; c number, such as BOOL, int, long, float, NSUInteger...</span><br><span class="line">     `NSString` -&gt; NSDate, parsed with format &quot;yyyy-MM-dd&apos;T&apos;HH:mm:ssZ&quot;, &quot;yyyy-MM-dd HH:mm:ss&quot; or &quot;yyyy-MM-dd&quot;.</span><br><span class="line">     `NSString` -&gt; NSURL.</span><br><span class="line">     `NSValue` -&gt; struct or union, such as CGRect, CGSize, ...</span><br><span class="line">     `NSString` -&gt; SEL, Class.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">+ (instancetype)yy_modelWithDictionary:(NSDictionary *)dictionary &#123;</span><br><span class="line">    if (!dictionary || dictionary == (id)kCFNull) return nil;</span><br><span class="line">    if (![dictionary isKindOfClass:[NSDictionary class]]) return nil;</span><br><span class="line"></span><br><span class="line">    // 创建当前类的类对象实例</span><br><span class="line">    Class cls = [self class];</span><br><span class="line">    // 创建和获取 模型的元类（包含类的详细信息）</span><br><span class="line">    _YYModelMeta *modelMeta = [_YYModelMeta metaWithClass:cls];</span><br><span class="line"></span><br><span class="line">    // 判断使用者是否自定义 类的（子类）类型</span><br><span class="line">    if (modelMeta-&gt;_hasCustomClassFromDictionary) &#123;</span><br><span class="line">        cls = [cls modelCustomClassForDictionary:dictionary] ?: cls;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 创建实例实例</span><br><span class="line">    NSObject *one = [cls new];</span><br><span class="line"></span><br><span class="line">    // 为属性赋值</span><br><span class="line">    if ([one yy_modelSetWithDictionary:dictionary]) return one;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>+ yy_modelWithDictionary:</code>方法中，主要做了三件事：1.确定类型；2.创建实例；3.为实例赋值。</p>
<h4 id="1-确定类型"><a href="#1-确定类型" class="headerlink" title="1. 确定类型"></a>1. 确定类型</h4><p>在类方法中使用<code>[self class]</code>可以轻松获取当前类的类对象，在这里作者通过类对象创建了该类的类元<code>_YYModelMeta *model</code>，类元中包含了丰富的关于该类的信息。</p>
<p><strong><code>_YYModelMeta</code> 类元的定义：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/// 模型对象的类元信息</span><br><span class="line">@interface _YYModelMeta : NSObject &#123;</span><br><span class="line">    @package</span><br><span class="line">    YYClassInfo *_classInfo;</span><br><span class="line">    /// Key:mapped key and key path, Value:_YYModelPropertyMeta.  数据结构：&#123;&quot;pic&quot;: [_YYModelPropertyMeta new]&#125;</span><br><span class="line">    NSDictionary *_mapper;</span><br><span class="line">    /// Array&lt;_YYModelPropertyMeta&gt;, 所有有效属性元的数组</span><br><span class="line">    NSArray *_allPropertyMetas;</span><br><span class="line">    /// Array&lt;_YYModelPropertyMeta&gt;, 映射到键值路径的属性元</span><br><span class="line">    NSArray *_keyPathPropertyMetas;</span><br><span class="line">    /// Array&lt;_YYModelPropertyMeta&gt;, 映射到多个键的属性元</span><br><span class="line">    NSArray *_multiKeysPropertyMetas;</span><br><span class="line">    /// 有效的键值对数量，所谓有效即包含 _getter、_setter、成员变量。 值与 _mapper.count 相同</span><br><span class="line">    NSUInteger _keyMappedCount;</span><br><span class="line">    /// 数据类型</span><br><span class="line">    YYEncodingNSType _nsType;</span><br><span class="line"></span><br><span class="line">    BOOL _hasCustomWillTransformFromDictionary;</span><br><span class="line">    BOOL _hasCustomTransformFromDictionary;</span><br><span class="line">    BOOL _hasCustomTransformToDictionary;</span><br><span class="line">    BOOL _hasCustomClassFromDictionary;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p>在确定类型之前，需要先判断使用者是否根据不同情况自定义了返回类的（子类）类型，即是否实现了<code>+ modelCustomClassForDictionary:(NSDictionary *)dictionary;</code>方法返回自定义类型。</p>
<p><strong>官方示例：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@class YYCircle, YYRectangle, YYLine;</span><br><span class="line"></span><br><span class="line">@implementation YYShape</span><br><span class="line"></span><br><span class="line">+ (Class)modelCustomClassForDictionary:(NSDictionary*)dictionary &#123;</span><br><span class="line">    if (dictionary[@&quot;radius&quot;] != nil) &#123;</span><br><span class="line">        return [YYCircle class];</span><br><span class="line">    &#125; else if (dictionary[@&quot;width&quot;] != nil) &#123;</span><br><span class="line">        return [YYRectangle class];</span><br><span class="line">    &#125; else if (dictionary[@&quot;y2&quot;] != nil) &#123;</span><br><span class="line">        return [YYLine class];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return [self class];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<h4 id="2-创建实例"><a href="#2-创建实例" class="headerlink" title="2. 创建实例"></a>2. 创建实例</h4><p>确定数据类型后，通过类对象快速创建实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSObject *one = [cls new];</span><br></pre></td></tr></table></figure></p>
<h4 id="3-为实例赋值"><a href="#3-为实例赋值" class="headerlink" title="3. 为实例赋值"></a>3. 为实例赋值</h4><p>调用 <code>-yy_modelSetWithDictionary:</code> 方法为实例赋值。</p>
<p><strong>代码：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)yy_modelSetWithDictionary:(NSDictionary *)dic &#123;</span><br><span class="line">    if (!dic || dic == (id)kCFNull) return NO;</span><br><span class="line">    if (![dic isKindOfClass:[NSDictionary class]]) return NO;</span><br><span class="line"></span><br><span class="line">    // 创建和获取 模型的元类（包含类的详细信息）</span><br><span class="line">    _YYModelMeta *modelMeta = [_YYModelMeta metaWithClass:object_getClass(self)];</span><br><span class="line"></span><br><span class="line">    // 判断当前类的有效属性数量</span><br><span class="line">    if (modelMeta-&gt;_keyMappedCount == 0) return NO;</span><br><span class="line"></span><br><span class="line">    // 判断使用者是否自定义了转换映射</span><br><span class="line">    if (modelMeta-&gt;_hasCustomWillTransformFromDictionary) &#123;</span><br><span class="line">        dic = [((id&lt;YYModel&gt;)self) modelCustomWillTransformFromDictionary:dic];</span><br><span class="line">        if (![dic isKindOfClass:[NSDictionary class]]) return NO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 创建 模型设置上下文</span><br><span class="line">    ModelSetContext context = &#123;0&#125;;</span><br><span class="line">    context.modelMeta = (__bridge void *)(modelMeta);</span><br><span class="line">    context.model = (__bridge void *)(self);</span><br><span class="line">    context.dictionary = (__bridge void *)(dic); //dic or json</span><br><span class="line"></span><br><span class="line">    //  比较 元模型的键值数量 &amp; 传入字典的键值数量</span><br><span class="line">    if (modelMeta-&gt;_keyMappedCount &gt;= CFDictionaryGetCount((CFDictionaryRef)dic)) &#123;</span><br><span class="line">        /**</span><br><span class="line">         @function CFDictionaryApplyFunction</span><br><span class="line">         对字典中的每个键值对调用函数一次。</span><br><span class="line"></span><br><span class="line">         @param  theDict</span><br><span class="line">         要查的字典。</span><br><span class="line"></span><br><span class="line">         @param  applier</span><br><span class="line">         要对字典中的每个值调用一次的回调函数。</span><br><span class="line"></span><br><span class="line">         @param context</span><br><span class="line">         一个指针大小的用户定义值，作为第三个参数传递给applier函数，但此函数不使用它。</span><br><span class="line"></span><br><span class="line">         */</span><br><span class="line">        CFDictionaryApplyFunction((CFDictionaryRef)dic, ModelSetWithDictionaryFunction, &amp;context);</span><br><span class="line"></span><br><span class="line">        if (modelMeta-&gt;_keyPathPropertyMetas) &#123;</span><br><span class="line">            CFArrayApplyFunction((CFArrayRef)modelMeta-&gt;_keyPathPropertyMetas,</span><br><span class="line">                                 CFRangeMake(0, CFArrayGetCount((CFArrayRef)modelMeta-&gt;_keyPathPropertyMetas)),</span><br><span class="line">                                 ModelSetWithPropertyMetaArrayFunction,</span><br><span class="line">                                 &amp;context);</span><br><span class="line">        &#125;</span><br><span class="line">        if (modelMeta-&gt;_multiKeysPropertyMetas) &#123;</span><br><span class="line">            CFArrayApplyFunction((CFArrayRef)modelMeta-&gt;_multiKeysPropertyMetas,</span><br><span class="line">                                 CFRangeMake(0, CFArrayGetCount((CFArrayRef)modelMeta-&gt;_multiKeysPropertyMetas)),</span><br><span class="line">                                 ModelSetWithPropertyMetaArrayFunction,</span><br><span class="line">                                 &amp;context);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        /**</span><br><span class="line">         @function CFArrayApplyFunction</span><br><span class="line">         对数组中的每个元素调用函数一次。</span><br><span class="line"></span><br><span class="line">         @param theArray</span><br><span class="line">         要操作的数组。</span><br><span class="line"></span><br><span class="line">         @param range</span><br><span class="line">         要将函数应用于的数组中的值范围。</span><br><span class="line"></span><br><span class="line">         @param applier</span><br><span class="line">         对数组中给定范围内的每个值调用一次的回调函数。如果此参数不是指向正确原型的函数的指针，则行为未定义。如果在应用程序函数期望的范围内存在或不能正确应用的值，则该行为是未定义的。</span><br><span class="line"></span><br><span class="line">         @param context</span><br><span class="line">         一个指针大小的用户定义值，它作为第二个参数传递给applier函数，但此函数不使用它。如果上下文不是applier函数所期望的内容，则行为是未定义的。</span><br><span class="line"></span><br><span class="line">         */</span><br><span class="line">        CFArrayApplyFunction((CFArrayRef)modelMeta-&gt;_allPropertyMetas,</span><br><span class="line">                             CFRangeMake(0, modelMeta-&gt;_keyMappedCount),</span><br><span class="line">                             ModelSetWithPropertyMetaArrayFunction,</span><br><span class="line">                             &amp;context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (modelMeta-&gt;_hasCustomTransformFromDictionary) &#123;</span><br><span class="line">        return [((id&lt;YYModel&gt;)self) modelCustomTransformFromDictionary:dic];</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里会先判断使用者是否对数据字典做了额外的处理，即是否实现了 <code>-modelCustomWillTransformFromDictionary:</code> 方法。如果有，则返回和使用自定义的字典。</p>
<p>一切准备就绪，创建模型设置上下文<code>ModelSetContext context</code>，准备赋值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    void *modelMeta;  ///&lt; _YYModelMeta 类元</span><br><span class="line">    void *model;      ///&lt; id (self) 实例本身</span><br><span class="line">    void *dictionary; ///&lt; NSDictionary (json) 数据字典（json）</span><br><span class="line">&#125; ModelSetContext;</span><br></pre></td></tr></table></figure></p>
<p>比较 <code>类元的有效键值数量</code> 和 <code>传入字典的键值数量</code>，以较小的代价进行属性的遍历赋值（减少不必要的循环次数）。这里分别使用<code>CFDictionaryApplyFunction( )</code>和<code>CFArrayApplyFunction( )</code> 对应 <code>ModelSetWithDictionaryFunction( )</code>和<code>ModelSetWithPropertyMetaArrayFunction( )</code>，进行遍历调用。二者最终都是通过 <code>ModelSetValueForProperty( )</code> 函数进行赋值的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static void ModelSetValueForProperty(__unsafe_unretained id model,// 实例对象</span><br><span class="line">                                     __unsafe_unretained id value,// 值</span><br><span class="line">                                     __unsafe_unretained _YYModelPropertyMeta *meta //属性元</span><br><span class="line">                                     )</span><br></pre></td></tr></table></figure>
<p><code>ModelSetValueForProperty( )</code> 函数中对属性的数据进行了详细的类型判断，主要分为三大类（C的基础数据类型、Foundation的NS数据类型、自定义数据类型）。除了C的基本数据类型，后者都通过消息发送 <code>objc_msgSend</code> 的方式，调用属性的 <code>meta-&gt;_setter</code> 方法进行赋值。</p>
<p>由于实现代码较长，这里就不展示了，有兴趣的可以自行查看源码：<a href="https://github.com/ibireme/YYModel/blob/master/YYModel/NSObject+YYModel.m" target="_blank" rel="noopener">《YYModel/NSObject+YYModel.m》第784~1098行</a>。</p>
<p>到此，JSON转模型的工作就完成了。</p>
<h2 id="模型转JSON"><a href="#模型转JSON" class="headerlink" title="模型转JSON"></a>模型转JSON</h2><h3 id="yy-modelToJSONString"><a href="#yy-modelToJSONString" class="headerlink" title="+ yy_modelToJSONString:"></a>+ yy_modelToJSONString:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (id)yy_modelToJSONObject &#123;</span><br><span class="line">    /*</span><br><span class="line">     Apple said:</span><br><span class="line">     The top level object is an NSArray or NSDictionary.</span><br><span class="line">     All objects are instances of NSString, NSNumber, NSArray, NSDictionary, or NSNull.</span><br><span class="line">     All dictionary keys are instances of NSString.</span><br><span class="line">     Numbers are not NaN or infinity.</span><br><span class="line">     */</span><br><span class="line">    id jsonObject = ModelToJSONObjectRecursive(self);</span><br><span class="line">    if ([jsonObject isKindOfClass:[NSArray class]]) return jsonObject;</span><br><span class="line">    if ([jsonObject isKindOfClass:[NSDictionary class]]) return jsonObject;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSData *)yy_modelToJSONData &#123;</span><br><span class="line">    id jsonObject = [self yy_modelToJSONObject];</span><br><span class="line">    if (!jsonObject) return nil;</span><br><span class="line">    return [NSJSONSerialization dataWithJSONObject:jsonObject options:0 error:NULL];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)yy_modelToJSONString &#123;</span><br><span class="line">    NSData *jsonData = [self yy_modelToJSONData];</span><br><span class="line">    if (jsonData.length == 0) return nil;</span><br><span class="line">    return [[NSString alloc] initWithData:jsonData encoding:NSUTF8StringEncoding];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从方法实现中不难看出，模型转JSON主要依赖于递归函数 <code>ModelToJSONObjectRecursive</code>，该函数最终将返回一个有效的JSON对象（NSArray/NSDictionary/NSString/NSNumber/NSNull）。</p>
<p><strong><code>ModelToJSONObjectRecursive</code> 内部实现代码拆解：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (!model || model == (id)kCFNull) return model;</span><br><span class="line">if ([model isKindOfClass:[NSString class]]) return model;</span><br><span class="line">if ([model isKindOfClass:[NSNumber class]]) return model;</span><br><span class="line">if ([model isKindOfClass:[NSURL class]]) return ((NSURL *)model).absoluteString;</span><br><span class="line">if ([model isKindOfClass:[NSAttributedString class]]) return ((NSAttributedString *)model).string;</span><br><span class="line">if ([model isKindOfClass:[NSDate class]]) return [YYISODateFormatter( ) stringFromDate:(id)model];</span><br><span class="line">if ([model isKindOfClass:[NSData class]]) return nil;</span><br></pre></td></tr></table></figure></p>
<p>当模型值符合或接近目标类型时，可做简单的转换或直接返回.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">// 字典</span><br><span class="line">if ([model isKindOfClass:[NSDictionary class]]) &#123;</span><br><span class="line">    if ([NSJSONSerialization isValidJSONObject:model]) return model;</span><br><span class="line">    NSMutableDictionary *newDic = [NSMutableDictionary new];</span><br><span class="line">    [((NSDictionary *)model) enumerateKeysAndObjectsUsingBlock:^(NSString *key, id obj, BOOL *stop) &#123;</span><br><span class="line">        NSString *stringKey = [key isKindOfClass:[NSString class]] ? key : key.description;</span><br><span class="line">        if (!stringKey) return;</span><br><span class="line">        id jsonObj = ModelToJSONObjectRecursive(obj);</span><br><span class="line">        if (!jsonObj) jsonObj = (id)kCFNull;</span><br><span class="line">        newDic[stringKey] = jsonObj;</span><br><span class="line">    &#125;];</span><br><span class="line">    return newDic;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 集合</span><br><span class="line">if ([model isKindOfClass:[NSSet class]]) &#123;</span><br><span class="line">    NSArray *array = ((NSSet *)model).allObjects;</span><br><span class="line">    if ([NSJSONSerialization isValidJSONObject:array]) return array;</span><br><span class="line">    NSMutableArray *newArray = [NSMutableArray new];</span><br><span class="line">    for (id obj in array) &#123;</span><br><span class="line">        if ([obj isKindOfClass:[NSString class]] || [obj isKindOfClass:[NSNumber class]]) &#123;</span><br><span class="line">            [newArray addObject:obj];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            id jsonObj = ModelToJSONObjectRecursive(obj);</span><br><span class="line">            if (jsonObj &amp;&amp; jsonObj != (id)kCFNull) [newArray addObject:jsonObj];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return newArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 数组</span><br><span class="line">if ([model isKindOfClass:[NSArray class]]) &#123;</span><br><span class="line">    if ([NSJSONSerialization isValidJSONObject:model]) return model;</span><br><span class="line">    NSMutableArray *newArray = [NSMutableArray new];</span><br><span class="line">    for (id obj in (NSArray *)model) &#123;</span><br><span class="line">        if ([obj isKindOfClass:[NSString class]] || [obj isKindOfClass:[NSNumber class]]) &#123;</span><br><span class="line">            [newArray addObject:obj];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            id jsonObj = ModelToJSONObjectRecursive(obj);</span><br><span class="line">            if (jsonObj &amp;&amp; jsonObj != (id)kCFNull) [newArray addObject:jsonObj];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return newArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当模型值为字典、集合数组类型时，需要遍历和递归其内部元素，直至逐一转化成有效的JSON对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">// 自定义类</span><br><span class="line">_YYModelMeta *modelMeta = [_YYModelMeta metaWithClass:[model class]];</span><br><span class="line">if (!modelMeta || modelMeta-&gt;_keyMappedCount == 0) return nil;</span><br><span class="line">NSMutableDictionary *result = [[NSMutableDictionary alloc] initWithCapacity:64];</span><br><span class="line">__unsafe_unretained NSMutableDictionary *dic = result; // avoid retain and release in block</span><br><span class="line">[modelMeta-&gt;_mapper enumerateKeysAndObjectsUsingBlock:^(NSString *propertyMappedKey, _YYModelPropertyMeta *propertyMeta, BOOL *stop) &#123;</span><br><span class="line">    if (!propertyMeta-&gt;_getter) return;</span><br><span class="line"></span><br><span class="line">    id value = nil;</span><br><span class="line">    if (propertyMeta-&gt;_isCNumber) &#123;</span><br><span class="line">        value = ModelCreateNumberFromProperty(model, propertyMeta);</span><br><span class="line">    &#125; else if (propertyMeta-&gt;_nsType) &#123;</span><br><span class="line">        id v = ((id (*)(id, SEL))(void *) objc_msgSend)((id)model, propertyMeta-&gt;_getter);</span><br><span class="line">        value = ModelToJSONObjectRecursive(v);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        switch (propertyMeta-&gt;_type &amp; YYEncodingTypeMask) &#123;</span><br><span class="line">            case YYEncodingTypeObject: &#123;</span><br><span class="line">                id v = ((id (*)(id, SEL))(void *) objc_msgSend)((id)model, propertyMeta-&gt;_getter);</span><br><span class="line">                value = ModelToJSONObjectRecursive(v);</span><br><span class="line">                if (value == (id)kCFNull) value = nil;</span><br><span class="line">            &#125; break;</span><br><span class="line">            case YYEncodingTypeClass: &#123;</span><br><span class="line">                Class v = ((Class (*)(id, SEL))(void *) objc_msgSend)((id)model, propertyMeta-&gt;_getter);</span><br><span class="line">                value = v ? NSStringFromClass(v) : nil;</span><br><span class="line">            &#125; break;</span><br><span class="line">            case YYEncodingTypeSEL: &#123;</span><br><span class="line">                SEL v = ((SEL (*)(id, SEL))(void *) objc_msgSend)((id)model, propertyMeta-&gt;_getter);</span><br><span class="line">                value = v ? NSStringFromSelector(v) : nil;</span><br><span class="line">            &#125; break;</span><br><span class="line">            default: break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!value) return;</span><br><span class="line"></span><br><span class="line">    if (propertyMeta-&gt;_mappedToKeyPath) &#123;</span><br><span class="line">        NSMutableDictionary *superDic = dic;</span><br><span class="line">        NSMutableDictionary *subDic = nil;</span><br><span class="line">        for (NSUInteger i = 0, max = propertyMeta-&gt;_mappedToKeyPath.count; i &lt; max; i++) &#123;</span><br><span class="line">            NSString *key = propertyMeta-&gt;_mappedToKeyPath[i];</span><br><span class="line">            if (i + 1 == max) &#123; // end</span><br><span class="line">                if (!superDic[key]) superDic[key] = value;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            subDic = superDic[key];</span><br><span class="line">            if (subDic) &#123;</span><br><span class="line">                if ([subDic isKindOfClass:[NSDictionary class]]) &#123;</span><br><span class="line">                    subDic = subDic.mutableCopy;</span><br><span class="line">                    superDic[key] = subDic;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                subDic = [NSMutableDictionary new];</span><br><span class="line">                superDic[key] = subDic;</span><br><span class="line">            &#125;</span><br><span class="line">            superDic = subDic;</span><br><span class="line">            subDic = nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (!dic[propertyMeta-&gt;_mappedToKey]) &#123;</span><br><span class="line">            dic[propertyMeta-&gt;_mappedToKey] = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>当模型值为自定义类型时，需要遍历和递归其映射表<code>_mapper</code>（{属性名: 属性元}），通过消息发送 <code>objc_msgSend</code> 的方式，调用属性的 <code>meta-&gt;_getter</code> 方法进行取值，直至逐一转化成有效的JSON对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (modelMeta-&gt;_hasCustomTransformToDictionary) &#123;</span><br><span class="line">    // 校验数据</span><br><span class="line">    BOOL suc = [((id&lt;YYModel&gt;)model) modelCustomTransformToDictionary:dic];</span><br><span class="line">    if (!suc) return nil;</span><br><span class="line">&#125;</span><br><span class="line">return result;</span><br></pre></td></tr></table></figure>
<p>最后，判断使用者是否有额外的转换处理，并并校验数据的有效性。</p>
<blockquote>
<p>注意：<code>result</code> 和 <code>dic</code> 指向的是同一个实例，所以如果 <code>dic</code> 在外部函数中被修改了，等同于修改了 <code>result</code>。</p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>YYModel的使用无侵入性，采用Category的方式实现功能，比较灵活。</li>
<li>容错方面，YYModel对数据类型做了详细的分类和判断，就算转换失败，也会自动留空（nil）。</li>
<li>性能方面，使用 <code>CoreFoundation</code>、内联函数、runtime、缓存机制等方式，减少不必要的开销。</li>
</ul>

      
      <!-- 打赏 -->
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/09/03/iOS源码阅读——YYModel/" data-id="ckevd229l001ekdbuyod90ycn"
        class="article-share-link">分享</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/YYModel/">YYModel</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码阅读/">源码阅读</a></li></ul>

    </footer>

  </div>

  

  

  

</article>
    
    <article id="post-2020年8月读书心得" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/08/31/2020年8月读书心得/"
    >2020年8月读书心得</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/08/31/2020年8月读书心得/" class="article-date">
  <time datetime="2020-08-31T15:15:49.000Z" itemprop="datePublished">2020-08-31</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/阅读/">阅读</a>
  </div>

      
      
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p><img src="https://img.alicdn.com/i1/2453833909/TB2x34gnVXXXXXFXpXXXXXXXXXX_!!2453833909.jpg_q90.jpg" alt=""></p>
<h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>起因是我在小专栏中看到了<a href="https://xiaozhuanlan.com/seestocks" target="_blank" rel="noopener">《美港股投资入门指南》 by 寂小桦</a>，就饶有兴趣的看起来。<br>可能很多人都渴望在股票的牛市里分到一杯羹，我也是其中一个。如果说仅仅是作为一个业余的投资者，恰当的股票投资，也能够为投资者带来可观的被动收入，这便是我对股票开始有兴趣的原因。专栏中还有一篇专门推荐<a href="https://xiaozhuanlan.com/topic/7952486301" target="_blank" rel="noopener">《给股票投资新手的书单》</a>。十分值得参考，《股票大作手回忆录》便是我读完的书单里的第一本书。</p>
<h3 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h3><blockquote>
<p>能看对波动方向的人很多，能看对波动并坚持不动的人才真正厉害。但是，一个股票投资者只有牢牢掌握了这个诀窍才能赚大钱。而这是最难学的。</p>
</blockquote>
<p>这里我就直接拿作者举例了。就算强如利弗摩尔这样的操盘手，在他的投资生涯当中也是几经沉浮，不断地上演破产又东山再起又破产的故事。原因恰恰都是因为他没有坚守自己的投资原则。本书没有太多的干货，但是不乏十分具体的操盘过程和细节，而作者始终想告诉读者的其实是，交易方法任何人都可以学习，而获得什么样的结果，最终取决于对自身的认知和心性。</p>
<blockquote>
<p>投资从无新鲜事。所有的一切都是轮回。</p>
</blockquote>
<p>此话无需多言，你品，你细品。</p>
<h3 id="股市永远是对的"><a href="#股市永远是对的" class="headerlink" title="股市永远是对的"></a>股市永远是对的</h3><blockquote>
<p>真正打败我的，是我没有继续坚持我的交易方法。换句话说，只有当市场上有先例支持我的交易计划时，我才做交易。</p>
</blockquote>
<p>任何投资都不应该仅凭主观意识下决定，而是应该通过市场和行情，甚至在有必要的时候，交上一笔”学费“，以证明当下的判断是对是错。不要因为跌了几个点，就慌乱了阵脚，相信自己的判断才是最重要的。</p>
<h3 id="在正确的时机买进卖出"><a href="#在正确的时机买进卖出" class="headerlink" title="在正确的时机买进卖出"></a>在正确的时机买进卖出</h3><blockquote>
<p>我从不介意告诉别人我对市场的看法，无论是看好还是看坏。但也仅仅于此，我从不会告诉别人是买进还是抛出具体的某种股票。</p>
</blockquote>
<p>作者在文中提到，许多人不会听取他对股市的分析和看法，他们只希望确切地知道到底该买什么，抛什么。”而和市场打交道，就应该默默无闻，一声不吭。否则，只会招来非议和提防。这对投资没有任何好处“</p>
<h3 id="真正的股市之王"><a href="#真正的股市之王" class="headerlink" title="真正的股市之王"></a>真正的股市之王</h3><blockquote>
<p>当投资机会来临时，不要畏首畏尾、裹足不前。如果有利可图，而风险又在可承受的范围内，就应果断地采取行动。—— 索罗斯</p>
</blockquote>
<p></p>

<blockquote>
<p>我一直遵循一条古老的交易原则，那就是当股票第一次上穿100美元、200美元或300美元时，上涨的趋势是不会就此止步的，只会升高更多。因而只要它一上穿关键点你就买，肯定能赚上一笔，胆小的人不喜欢在股价创新高时买入股票，但我却有类似的“史实”来指引我在这个时候大胆买入。</p>
</blockquote>
<p></p>

<blockquote>
<p>对我来说，赚钱的方法就是行动起来，而赚大钱的方法却是要在机会来临的时候做出正确的选择。在这一行业你要理论结合实际，绝不能只做书面研究，而是既要做一个研究者，又要做一个投机者。</p>
</blockquote>
<p>个人感觉，作者的经验，仅适用于作者本人。因为文中其实多次提到，利弗摩尔经常会有要抛出或买进某只股票的预感，值得注意的是，这种预感不是空穴来风的。或许是因为他几十年作手生涯积累的经验和直觉，在潜意识中告诉了他答案。所以作者想告诉我们的是，如果建立起了自己的交易原则，且行情风险又恰好都在能接受的体系之内，就应该相信自己，果断采取行动，抓住赚取利润的机会。</p>
<h3 id="别让希望和恐惧伤害你"><a href="#别让希望和恐惧伤害你" class="headerlink" title="别让希望和恐惧伤害你"></a>别让希望和恐惧伤害你</h3><blockquote>
<p>在所有游戏中，唯一真正需要在行动前做好准备的恰恰是准备本身，有些人在用他一半的财产冒险时，用来准备的时间还没有买一辆平价汽车考虑的时间久。</p>
</blockquote>
<p></p>

<blockquote>
<p>在建仓的过程中，总会先亏掉5万或6万美元去测试市场。看起来这种测试的代价确实不小，但事实并非如此，当真正的行情开始时，这点亏损很快就会赚回来，只有把握住正确的机会才能赚到钱。</p>
</blockquote>
<p></p>

<blockquote>
<p>我对自己的交易方法已经说得很清楚了，只在稳操胜券的时候才下大注，而犯错的时候只亏损一点探测性的赌注，这种做法相当英明。如果按我说的方法去交易，就可以始终持有有利润的头寸，回报也总是最为丰厚。</p>
</blockquote>
<p>大多数情况下，股市并不会像投机者心里一厢情愿所期盼的方向发展，如果心中有了预测方向，接下去要做的就应该是通过少量下注和跟踪来论证自己的假设，检验市场的走势和自己的判断是否一致或者相悖，不管结局是哪一种，按做好计划，按计划执行，大概率地情况下，能够赚取到不错的利润，或者规避掉可能的损失。永远不要去打无准备的战争，不然结局可能会很惨。</p>
<blockquote>
<p>投机商真正的敌人往往是自己内心的想法，它与人性的希望和恐惧融为一体。在交易中，当市场对你不利时，你总是希望这一天早日结束，但你失去的总是比你预想的要多；当市场一旦按你的方向走，你就会心生恐惧，担心第二天你的利润就没有了，于是迅速终结交易。恐惧使你没有勇气赚得即将到手的钱，一个成功的交易商必须要战胜这两种根深蒂固的本能，打消本能的冲动。别人认为充满希望的时候警惕谨慎，而别人徘徊犹豫的时候大胆出手。他必须时刻警惕他的亏损会让自己无力承受，也必须希望他的利润能迅猛增长。平常人对股票所持有的赌博观念是十分错误的。</p>
</blockquote>
<p>每个人都应该有自己的交易原则和止损线，而不应该让贪婪和恐惧侵占了大脑中所有的理智。</p>
<h3 id="交易者无法离开市场"><a href="#交易者无法离开市场" class="headerlink" title="交易者无法离开市场"></a>交易者无法离开市场</h3><blockquote>
<p>对于业余投资者来说，非常重要的一点是要用一种适当怀疑的眼光来审视专业投资人，至少这样做可以让你弄清楚在投资中你所面对的是一些什么样的人。由于主要上市公司70%的股票都掌握在机构投资者手中，因此不论你是买入还是卖出股票的时候，你所面对的投资竞争对手是专业投资者的可能性越来越大。—— 彼得·林奇</p>
</blockquote>
<p>论投机，个人应该是玩儿不过机构投资者，所以个人投资更应该倾向于对上市公司长期的价值投资，而非短期投机。</p>
<h3 id="投机者要接受必要的训练"><a href="#投机者要接受必要的训练" class="headerlink" title="投机者要接受必要的训练"></a>投机者要接受必要的训练</h3><blockquote>
<p>业余投资者只要花少量时间，研究自己比较熟悉的行业中的几家上市公司，股票投资业绩就能超过95%的管理基金的专业投资者，而且会从中得到许多乐趣。—— 彼得·林奇</p>
</blockquote>
<p>即：做认知内的投资。</p>
<h3 id="当心“匿名内幕人”的“忠告”"><a href="#当心“匿名内幕人”的“忠告”" class="headerlink" title="当心“匿名内幕人”的“忠告”"></a>当心“匿名内幕人”的“忠告”</h3><blockquote>
<p>大众必须牢记一点：股价长期下跌绝不是空头打压所致。一只股票不断下跌时，背后一定存在着隐情，不是市场有问题，就是公司本身有问题。</p>
</blockquote>
<p>由于作手的操盘，造成短期内走势出现较大的波动，是有可能的。但从长期来看，股票的价格，体现的是公司的价值所在，这才是投资的本质和初衷。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>作者在书中多处详细地描述了他在期货、股票上的操作，值得多读细品。对于我一个股市小白来说，收货还是很大的。入股市之前，提升专业知识和自我认知尤为重要。操作股票不仅需要技巧，更是考验人性的一件事。</p>

      
      <!-- 打赏 -->
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/31/2020年8月读书心得/" data-id="ckevd228z000ckdbuap3n7crl"
        class="article-share-link">分享</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/读书心得/">读书心得</a></li></ul>

    </footer>

  </div>

  

  

  

</article>
    
    <article id="post-LPR浮动利率究竟是什么？" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/08/29/LPR浮动利率究竟是什么？/"
    >LPR浮动利率究竟是什么？</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/08/29/LPR浮动利率究竟是什么？/" class="article-date">
  <time datetime="2020-08-29T05:40:19.000Z" itemprop="datePublished">2020-08-29</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/科普/">科普</a>
  </div>

      
      
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h3 id="写作目的"><a href="#写作目的" class="headerlink" title="写作目的"></a>写作目的</h3><p>相信各位可能和我一样，在前段时间收到了一条短信，内容大致为：</p>
<blockquote>
<p>按照人民银行[2019]30号公告要求，为简化您的操作，XX银行将于2020年8月25日起将您在我行的住房贷款转换为LPR浮动利率定价方式。</p>
</blockquote>
<p>此时的我，一脸懵逼，LPR利率是个什么玩儿？它还是浮动的？那岂不是以后的利息都没准儿？利息有可能会升高吗？</p>
<p>在观看了B站李永乐老师的视频<a href="https://www.bilibili.com/video/BV1AJ41157sM" target="_blank" rel="noopener">《房贷合同要变了！LPR利率和固定利率哪个合算？会影响房价走势吗?》</a>之后，对LPR浮动利率和利率转换有了一定的认识，在这里和大家分享一下。</p>
<h3 id="贷款基准利率"><a href="#贷款基准利率" class="headerlink" title="贷款基准利率"></a>贷款基准利率</h3><p>在实行LPR浮动利率之前，我们实行的是贷款基准利率，商业银行的利率计算公式为：</p>
<blockquote>
<p>商业银行贷款利率 = 基准利率 * (1 + 浮动加点)<br>央行基准利率：4.9%（2015公布~至今）<br>浮点：根据央行、政策、银行、个人情况而定</p>
</blockquote>
<p>实例：假设某个城市对首套房的浮动加点是10%，那么我们的贷款利率就是：</p>
<blockquote>
<p>首套贷款利率：4.9% * (1 + 10%) = 5.39%</p>
</blockquote>
<p>数字先放这儿，后面会用到。</p>
<h3 id="利率的双轨制"><a href="#利率的双轨制" class="headerlink" title="利率的双轨制"></a>利率的双轨制</h3><p>原有的贷款利率带来的问题是，<code>市场利率</code>和<code>政策利率</code>存在双轨制。<br>市场利率也就是市场对资金需求程度，决定了利率的变化。市场如果非常需要资金，那么利率就上升；如果市场资金比较充裕，那么利率相对地就会下降。<br>这里涉及到MLF利率的问题，MLF的定义，我们不去管它，大体理解就是，央行给商行投钱，商行需要一些抵押给央行，后期在通过一定利率将钱还给央行，这里就存在一个MLF利率。<br>而政策利率，主要指的就是基准利率。商行拿到钱之后，再加上一定的浮动，贷款给客人或企业。<br>这样会出现一个问题，那就是货币政策传导不畅。<br>当MLF下调，商行拿到了钱。但是基准利率没有及时下调，那么贷款利率还是很高，那么个人和企业还是很难贷到钱。<br>这就是利率双轨制存在的问题。</p>
<h3 id="贷款基础利率"><a href="#贷款基础利率" class="headerlink" title="贷款基础利率"></a>贷款基础利率</h3><p>也就是LPR利率。简单说：</p>
<blockquote>
<p>LPR利率 ＝ MLF利率 + 商行平均加点</p>
</blockquote>
<p>这里的商行平均加点，是怎么得来的呢？<br>它是由国内选出来的18家商业银行，一起来报价决定，这18家银行可能来自大型国有银行，城市银行，外资银行和物联网银行等不同的类型。这些银行有不同的特色，服务于不同的人群，可以综合地从各个方面代表整体的市场情况。由这些银行各自根据市场情况报价，最后去除最高和最低，取平均即可。</p>
<p>在LPR利率下，我们的贷款利率就变为了：</p>
<blockquote>
<p>贷款利率 ＝ LPR利率 + 政策加点 + 商行附加利率<br>LPR利率：4.8%（2019年12月）<br>政策加点：如果国家觉得首套房利率不能下浮，那至少要保持LPR利率，那么政策加点可是是0%；限制二套房的购买，那二套房的政策加点可以定为0.6%<br>商行附加利率：商行需要盈利，所以也会有个加点。假设是0.59%</p>
</blockquote>
<p>那么首套房和二套房的利率就分别为：</p>
<blockquote>
<p>首套：4.8% + 0% + 0.59% = 5.39%<br>二套：4.8% + 0.6% + 0.59% = 5.99%</p>
</blockquote>
<p>以上都是针对新利率执行之后的贷款进行的解释，没有太大问题。而接下来就是我们最关心的问题，还在还款期内的贷款是如何转换的。</p>
<h3 id="基准利率-转-基础理论"><a href="#基准利率-转-基础理论" class="headerlink" title="基准利率 转 基础理论"></a>基准利率 转 基础理论</h3><p>根据国家政策，在转化的第一年的一整年时间里，也就是2020年，它会保证我们的利率是和2019年12月20日是一模一样的。（上文我们假定了我们原先的贷款利率是5.39%）。细心的童鞋一定发现了，原先的贷款利率和LPR利率之间存在一个差值，我们可以称这个差值为<code>加点</code>，因为这是我们后期利率计算的条件之一。</p>
<blockquote>
<p>原有贷款利率 = LPR利率 + 加点(差值)<br>5.39% = 4.8% + <u>0.59%</u><br>注意：原本的利率如果是低于LPR利率的，加点值允许是负的。</p>
</blockquote>
<p>得到了加点的具体指，那么我们以后每年的房贷利率就会根据LPR的调整而改变了。有些人可能会担心，如果LPR上升了，我的贷款利率不就上去了吗？根据世界范围的运行规律，国家发展到一定程度后，利率都是会下降的。长期来看，利率下行的概率应该是高于利率上行的概率的。<br>下面附上一张近一年的利率走势表，供大家参考。</p>
<table>
<thead>
<tr>
<th>日期</th>
<th>1年期LPR利率（%）</th>
<th>5年期LPR利率（%）</th>
</tr>
</thead>
<tbody>
<tr>
<td>2020-08-20</td>
<td>3.85</td>
<td>4.65</td>
</tr>
<tr>
<td>2020-07-20</td>
<td>3.85</td>
<td>4.65</td>
</tr>
<tr>
<td>2020-06-20</td>
<td>3.85</td>
<td>4.65</td>
</tr>
<tr>
<td>2020-05-20</td>
<td>3.85</td>
<td>4.65</td>
</tr>
<tr>
<td>2020-04-20</td>
<td>3.85</td>
<td>4.65</td>
</tr>
<tr>
<td>2020-03-20</td>
<td>4.05</td>
<td>4.75</td>
</tr>
<tr>
<td>2020-02-20</td>
<td>4.05</td>
<td>4.75</td>
</tr>
<tr>
<td>2020-01-20</td>
<td>4.15</td>
<td>4.80</td>
</tr>
<tr>
<td>2019-12-20</td>
<td>4.15</td>
<td>4.80</td>
</tr>
<tr>
<td>2019-11-20</td>
<td>4.15</td>
<td>4.80</td>
</tr>
<tr>
<td>2019-10-20</td>
<td>4.20</td>
<td>4.85</td>
</tr>
<tr>
<td>2019-09-20</td>
<td>4.20</td>
<td>4.85</td>
</tr>
<tr>
<td>2019-08-20</td>
<td>4.25</td>
<td>4.85</td>
</tr>
</tbody>
</table>

      
      <!-- 打赏 -->
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/29/LPR浮动利率究竟是什么？/" data-id="ckevd229e0010kdbuv33kxjf6"
        class="article-share-link">分享</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LPR/">LPR</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/金融/">金融</a></li></ul>

    </footer>

  </div>

  

  

  

</article>
    
    <article id="post-LeetCode算法学习日记（2020年8月）" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/08/28/LeetCode算法学习日记（2020年8月）/"
    >LeetCode算法学习日记（2020年8月）</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/08/28/LeetCode算法学习日记（2020年8月）/" class="article-date">
  <time datetime="2020-08-28T12:04:05.000Z" itemprop="datePublished">2020-08-28</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/算法/">算法</a>
  </div>

      
      
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h3 id="2020-8-14"><a href="#2020-8-14" class="headerlink" title="2020.8.14"></a>2020.8.14</h3><hr>
<p><b>题目：</b>有效的括号<br><b>解题思路：</b>栈<br><b>示例：</b></p>
<blockquote>
<p>输入： “( ) [ ] { }”<br>输出： true</p>
<p>输入： “( [ ) ]”<br>输出： false</p>
</blockquote>
<p><b>代码：</b><br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">isValid</span><span class="params">(<span class="number">_</span> s: String)</span></span> -&gt; <span class="type">Bool</span> &#123;       </span><br><span class="line">    <span class="keyword">if</span> s.isEmpty &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> dic:[<span class="type">Character</span>:<span class="type">Int</span>] = [<span class="string">"("</span>:<span class="number">1</span>,<span class="string">")"</span>:<span class="number">2</span>,<span class="string">"["</span>:<span class="number">3</span>,<span class="string">"]"</span>:<span class="number">4</span>,<span class="string">"&#123;"</span>:<span class="number">5</span>,<span class="string">"&#125;"</span>:<span class="number">6</span>]</span><br><span class="line">    <span class="keyword">var</span> arr = [s[s.startIndex]]</span><br><span class="line">    <span class="keyword">var</span> isSkip = <span class="literal">false</span> <span class="comment">//是否清空</span></span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">1</span>..&lt;s.<span class="built_in">count</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> currentS : <span class="type">Character</span> = s[s.index(s.startIndex, offsetBy: index)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> isSkip &#123;</span><br><span class="line">            isSkip = <span class="literal">false</span></span><br><span class="line">            arr = [currentS]</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> lastS : <span class="type">Character</span>? = arr.last</span><br><span class="line">        <span class="keyword">let</span> currentNum = dic[currentS] <span class="comment">// 当前符号代表的数</span></span><br><span class="line">        <span class="keyword">let</span> lastNum = dic[lastS!] <span class="comment">// 栈顶符号代表的数</span></span><br><span class="line">        <span class="keyword">if</span> (lastNum! == <span class="number">1</span> &amp;&amp; currentNum! == <span class="number">2</span>) || (lastNum! == <span class="number">3</span> &amp;&amp; currentNum! == <span class="number">4</span>) || (lastNum! == <span class="number">5</span> &amp;&amp; currentNum! == <span class="number">6</span>)&#123;</span><br><span class="line">            arr.removeLast()</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            arr.append(currentS)</span><br><span class="line">        &#125;</span><br><span class="line">        isSkip = (arr.<span class="built_in">count</span> == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr.<span class="built_in">count</span> &gt; <span class="number">0</span> ? <span class="literal">false</span> : <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><b>算法理解：</b><br>当我们在遍历的时候，遇到左括号，就希望在后续中有右括号与之对应。根据先出现的左括号，延后对应，后出现的左括号，遇到右括号先对应的特点，栈的特点非常适合这道题的解题思路（先进后出）。<br>我们可以依次将一个符号压入栈顶，当有左括号遇到右括号时，两两相消，一直到最后如果栈内符号全部消除，则说明这组符号是有效的。</p>

      
      <!-- 打赏 -->
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/28/LeetCode算法学习日记（2020年8月）/" data-id="ckevd2299000rkdbu5lzriod3"
        class="article-share-link">分享</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LeetCode/">LeetCode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Swift/">Swift</a></li></ul>

    </footer>

  </div>

  

  

  

</article>
    
    <article id="post-简单瀑布流布局实现（Swift）" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/08/27/简单瀑布流布局实现（Swift）/"
    >简单瀑布流布局实现（Swift）</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/08/27/简单瀑布流布局实现（Swift）/" class="article-date">
  <time datetime="2020-08-27T13:21:38.000Z" itemprop="datePublished">2020-08-27</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

      
      
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h3 id="写作目的"><a href="#写作目的" class="headerlink" title="写作目的"></a>写作目的</h3><p>前段时间面试，问了瀑布流布局，所以就想到写这篇文章分享一下相关的知识点。<br>瀑布流布局是一种常见的布局方式，它能够美观、灵活地展示不同高度的素材组合的视图控件。<br>瀑布流布局的特点就在于，item从上往下排列，每次item的放置位置，都是当前的最短列下方。</p>
<h3 id="主要的类"><a href="#主要的类" class="headerlink" title="主要的类"></a>主要的类</h3><ul>
<li>UICollectionView：视图</li>
<li>UICollectionViewFlowLayout：布局</li>
<li>UICollectionViewLayoutAttributes：item配置</li>
</ul>
<h3 id="需要重写的系统方法"><a href="#需要重写的系统方法" class="headerlink" title="需要重写的系统方法"></a>需要重写的系统方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1) 准备布局（第一次布局和刷新时调用）</span><br><span class="line">override func prepare</span><br><span class="line">2) 设置视图内容的尺寸</span><br><span class="line">override var collectionViewContentSize: CGSize</span><br><span class="line">3) 返回计算好的属性数组</span><br><span class="line">override func layoutAttributesForElements(in rect: CGRect) -&gt; [UICollectionViewLayoutAttributes]?</span><br></pre></td></tr></table></figure>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><h4 id="视图-amp-数据源"><a href="#视图-amp-数据源" class="headerlink" title="视图&amp;数据源"></a>视图&amp;数据源</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">import UIKit</span><br><span class="line"></span><br><span class="line">class ViewController: UIViewController, UICollectionViewDelegate, UICollectionViewDataSource &#123;</span><br><span class="line"></span><br><span class="line">    // 数据源</span><br><span class="line">    var dataArr = [Int]()</span><br><span class="line">    // 列数</span><br><span class="line">    let columnCount:Int = 3;</span><br><span class="line">    // 瀑布流布局</span><br><span class="line">    var flowLayout: WaterfallFlowLayout!</span><br><span class="line"></span><br><span class="line">    var collectionView: UICollectionView!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //MARK: - --- 视图已经加载</span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">        super.viewDidLoad()</span><br><span class="line">        // 数据源，同时也是高度值（实际项目中应根据内容计算高度）</span><br><span class="line">        self.dataArr = [300,200,300,400,100,200,300,400,100,200,300,400,100,200,300,400]</span><br><span class="line">        self.createUI()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //MARK: - --- 创建UI</span><br><span class="line">    func createUI()&#123;</span><br><span class="line">        // 创建collectionView视图 和 flowLayout布局</span><br><span class="line">        self.flowLayout = WaterfallFlowLayout()</span><br><span class="line">        self.flowLayout.dataArr = self.dataArr</span><br><span class="line">        let rect: CGRect = CGRect(origin: CGPoint(x: 0, y: 0), size: CGSize(width: SCREEN_WIDTH, height: SCREEN_HEIGHT))</span><br><span class="line">        let collectionView = UICollectionView.init(frame: rect, collectionViewLayout:self.flowLayout)</span><br><span class="line">        collectionView.delegate = self</span><br><span class="line">        collectionView.dataSource = self</span><br><span class="line">        collectionView.backgroundColor = UIColor.white</span><br><span class="line">        collectionView.register(UICollectionViewCell.self, forCellWithReuseIdentifier: &quot;HomeCell&quot;)</span><br><span class="line">        self.view.addSubview(collectionView)</span><br><span class="line">        self.collectionView = collectionView</span><br><span class="line"></span><br><span class="line">        // 设置布局属性</span><br><span class="line">        self.setWaterfallFlowLayouts()</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //MARK: - --- 设置item的布局</span><br><span class="line">    func setWaterfallFlowLayouts()&#123;</span><br><span class="line">        // 设置布局属性</span><br><span class="line">        self.flowLayout.columnCount = self.columnCount</span><br><span class="line">        // 边界</span><br><span class="line">        self.flowLayout.sectionInset = UIEdgeInsets.init(top: 10, left: 10, bottom: 10, right: 10)</span><br><span class="line">        // 设置间距</span><br><span class="line">        self.flowLayout.minimumLineSpacing = 10.0</span><br><span class="line">        self.flowLayout.minimumInteritemSpacing = 10.0</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //MARK: - --- delegate，dataSource</span><br><span class="line">    func numberOfSections(in collectionView: UICollectionView) -&gt; Int &#123;</span><br><span class="line">        return 1</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -&gt; Int &#123;</span><br><span class="line">        return self.dataArr.count</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -&gt; UICollectionViewCell &#123;</span><br><span class="line">        let cell:UICollectionViewCell = collectionView.dequeueReusableCell(withReuseIdentifier: &quot;HomeCell&quot;, for: indexPath)</span><br><span class="line">        cell.backgroundColor = .red</span><br><span class="line">        cell.layer.cornerRadius = 8</span><br><span class="line">        cell.layer.masksToBounds = true</span><br><span class="line"></span><br><span class="line">        var label: UILabel!</span><br><span class="line"></span><br><span class="line">        if let lab: UILabel = cell.contentView.subviews.last as? UILabel&#123;</span><br><span class="line">            label = lab</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            label = UILabel.init(frame: CGRect.init(x: 0, y: 0, width: 30, height: 30))</span><br><span class="line">            label.textAlignment = .center</span><br><span class="line">            cell.contentView.addSubview(label)</span><br><span class="line">            label.textColor = .white</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        label.text = &quot;\(indexPath.row)&quot;</span><br><span class="line">        return cell</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) &#123;</span><br><span class="line">        // 点击添加数据</span><br><span class="line">        self.dataArr += [300,200,300,400,100,200,300,400,100,200,300,400,100,200,300,400]</span><br><span class="line">        self.flowLayout.dataArr = self.dataArr</span><br><span class="line">        self.collectionView.reloadData()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h3><h4 id="计算布局"><a href="#计算布局" class="headerlink" title="计算布局"></a>计算布局</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">let SCREEN_WIDTH = UIScreen.main.bounds.size.width</span><br><span class="line">let SCREEN_HEIGHT = UIScreen.main.bounds.size.height</span><br><span class="line"></span><br><span class="line">class WaterfallFlowLayout: UICollectionViewFlowLayout &#123;</span><br><span class="line">    // 总列数</span><br><span class="line">    var columnCount:Int = 0</span><br><span class="line">    // 数据数组</span><br><span class="line">    var dataArr = [Int]()</span><br><span class="line">    // 整个collectionView的高度</span><br><span class="line">    private var maxH:Int?</span><br><span class="line">    //所有item的属性</span><br><span class="line">    fileprivate var layoutAttributesArray = [UICollectionViewLayoutAttributes]()</span><br><span class="line"></span><br><span class="line">    // 准备布局时调用</span><br><span class="line">    override func prepare() &#123;</span><br><span class="line">        /**</span><br><span class="line">         *  计算每个item的宽度</span><br><span class="line">         *  即：(collectionView的宽度 - 左右边距和 - item的水平间距之和) / 每行的item数量</span><br><span class="line">         */</span><br><span class="line">        let itemWidth = ((self.collectionView?.bounds.size.width)! - self.sectionInset.left - self.sectionInset.right - self.minimumInteritemSpacing * CGFloat(self.columnCount - 1)) / CGFloat.init(self.columnCount)</span><br><span class="line"></span><br><span class="line">        // 通过item的宽度，计算并设置属性</span><br><span class="line">        self.computeAttributesWithItemWidth(CGFloat(itemWidth))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ///根据itemWidth计算布局属性</span><br><span class="line">    func computeAttributesWithItemWidth(_ itemWidth:CGFloat)&#123;</span><br><span class="line"></span><br><span class="line">        // 定义一个列高数组 记录每一列的总高度（初始值都为上边距）</span><br><span class="line">        var columnHeightArr = [Int](repeating: Int(self.sectionInset.top), count: self.columnCount)</span><br><span class="line">        // 定义一个 记录每一列的item个数的数组</span><br><span class="line">        var columnItemCountArr = [Int](repeating: 0, count: self.columnCount)</span><br><span class="line"></span><br><span class="line">        // 定义一个 存储属性的临时数组</span><br><span class="line">        var attributesArray = [UICollectionViewLayoutAttributes]()</span><br><span class="line"></span><br><span class="line">        // 遍历数据计算每个item的属性并布局</span><br><span class="line">        for (index, dj_height) in self.dataArr.enumerated() &#123;</span><br><span class="line"></span><br><span class="line">            // 根据IndexPath获取Cell元素的属性</span><br><span class="line">            let attributes = UICollectionViewLayoutAttributes.init(forCellWith: IndexPath.init(item: index, section: 0))</span><br><span class="line">            // 找出最短列的下标</span><br><span class="line">            let minHeight:Int = columnHeightArr.sorted().first!</span><br><span class="line">            let column = columnHeightArr.firstIndex(of: minHeight)</span><br><span class="line"></span><br><span class="line">            // 将数据追加在最短列</span><br><span class="line">            columnItemCountArr[column!] += 1</span><br><span class="line">            // 计算该项的坐标</span><br><span class="line">            let itemX = (itemWidth + self.minimumInteritemSpacing) * CGFloat(column!) + self.sectionInset.left</span><br><span class="line">            let itemY = minHeight</span><br><span class="line">            // 计算item的高度（机型适配，注意比例缩放）</span><br><span class="line">            let itemH = dj_height</span><br><span class="line">            // 设置frame</span><br><span class="line">            attributes.frame = CGRect(x: itemX, y: CGFloat(itemY), width: itemWidth, height: CGFloat(itemH))</span><br><span class="line"></span><br><span class="line">            attributesArray.append(attributes)</span><br><span class="line">            // 累加列高</span><br><span class="line">            columnHeightArr[column!] += itemH + Int(self.minimumLineSpacing)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 找出最高列的下标</span><br><span class="line">        let maxHeight:Int = columnHeightArr.sorted().last!</span><br><span class="line">        let maxHeightColumnIndex = columnHeightArr.firstIndex(of: maxHeight)</span><br><span class="line">        // 根据最高列设置itemSize的默认值 使用总高度的平均值</span><br><span class="line">        let itemH = (maxHeight - Int(self.minimumLineSpacing) * (columnItemCountArr[maxHeightColumnIndex!] + 1)) / columnItemCountArr[maxHeightColumnIndex!]</span><br><span class="line">        self.itemSize = CGSize(width: itemWidth, height: CGFloat(itemH))</span><br><span class="line">        // 给属性数组设置数值</span><br><span class="line">        self.layoutAttributesArray = attributesArray</span><br><span class="line">        // 将最高列的行高赋值给属性，作为contentSize.Height的值</span><br><span class="line">        self.maxH = maxHeight</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 返回计算好的layoutAttributesArray数组</span><br><span class="line">    override func layoutAttributesForElements(in rect: CGRect) -&gt; [UICollectionViewLayoutAttributes]? &#123;</span><br><span class="line"></span><br><span class="line">        return self.layoutAttributesArray</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 重写设置contentSize</span><br><span class="line">    override var collectionViewContentSize: CGSize &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            return CGSize(width: (collectionView?.bounds.width)!, height: CGFloat(self.maxH!))</span><br><span class="line">        &#125;</span><br><span class="line">        set &#123;</span><br><span class="line">            self.collectionViewContentSize = newValue</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本篇文章主要是对瀑布流的原理进行概述和提供思路，不涉及网络请求，动态内容计算等方面，应该还算是简单易懂的。感兴趣童鞋的可以<a href="https://github.com/a334713698/WaterfallFlow" target="_blank" rel="noopener">Github</a>上下载，欢迎交流学习。</p>

      
      <!-- 打赏 -->
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/27/简单瀑布流布局实现（Swift）/" data-id="ckevd229v0021kdbuggt97ljk"
        class="article-share-link">分享</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Swift/">Swift</a></li></ul>

    </footer>

  </div>

  

  

  

</article>
    
    <article id="post-2020年5月读书心得" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/05/08/2020年5月读书心得/"
    >2020年5月读书心得</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/05/08/2020年5月读书心得/" class="article-date">
  <time datetime="2020-05-08T14:18:30.000Z" itemprop="datePublished">2020-05-08</time>
</a>
      
      
      
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1geleneei4bj30bw0h4dif.jpg" alt=""><br>《原则》是一本几乎真本书都是干货的书。作者在40年的工作和生活中，有“记录”的习惯，通过记录经历总结经验，将工作和生活良好地经营和管理起来。<br>作者在书中推荐阅读“生活原则”的全部内容，并将概要与列表放在章节的最后，而“工作原则”可根据需要进行选读，则把概要与列表放在了章节的开头，这一点十分贴心。<br>这本书更适合在实践中去借鉴书中的方法，并优化创造出属于自己的原则。</p>
<p>本书的第一章主要讲述的是坐着的历程：作者白手起家创建桥水基金，并通过努力获取了不错的成绩。1982年8月，墨西哥对其债务违约（其他国家有可能也会步其后尘），而美国银行正在想墨西哥一样高风险的其他国家提供贷款。而作者认为自己是少数预见到这一情况的人，并自信地表示美国会走向一场大萧条。而事实是，美联储通过增加货币供给，以一种无通胀的方式复兴了。作者感觉像是不断地被球棒打自己的头，因为这是他在众目睽睽下的失败。这使他失去了8年的努力，回到的原点。</p>
<p>不过逆境没有阻挡作者的脚步。他又逐渐培养了新的客户，逐渐新的团队。他开始容忍逆境，并吸取教训，走向更大的成果。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本书中给我做大的感悟就是，在人生的道路上一定要有所成长，而成长的过程一定是痛苦的，一定要清楚这一点。同时对于实现目标的方式方法，不能过于固执己见，需要通过自己的反复复盘和值得信赖的人的佐证，不断提高其实现的概率，直到目标实现。</p>

      
      <!-- 打赏 -->
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/05/08/2020年5月读书心得/" data-id="ckevd228u0006kdbu4ayl9oqq"
        class="article-share-link">分享</a>
      
    </footer>

  </div>

  

  

  

</article>
    
    <article id="post-2020年4月读书心得" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/04/10/2020年4月读书心得/"
    >2020年4月读书心得</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/04/10/2020年4月读书心得/" class="article-date">
  <time datetime="2020-04-10T13:49:13.000Z" itemprop="datePublished">2020-04-10</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/阅读/">阅读</a>
  </div>

      
      
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdp0j616sgj30bw0h4woj.jpg" alt=""></p>
<h2 id="《养育男孩》"><a href="#《养育男孩》" class="headerlink" title="《养育男孩》"></a>《养育男孩》</h2><p>写这篇读书心得的时候，距离儿子的六月龄还有一周时间。我和妻子感谢上天赐给我们如此可爱的孩子，也开始理解父母对孩子的那种爱。<br>初为人父母，从宝宝出生地那一刻开始，无不督促着我们这些本来也还是“孩子”的人，突然转变角色，无条件地为了这个小生命，付出自己的一切。<br>未来虽然还很远，谁也不是孩子一出生就是个好父母，我们需要和孩子一起学习，一起成长。<br>《养育男孩》这本书，有非常多的干货，我在书的许多地方都做了笔记，可以在孩子的不同年龄阶段，尝试能够理解和帮助我们的孩子。</p>
<h3 id="父亲必须做的5件事"><a href="#父亲必须做的5件事" class="headerlink" title="父亲必须做的5件事"></a>父亲必须做的5件事</h3><blockquote>
<p>提前“触摸”孩子<br>抽空陪伴孩子<br>亲近孩子<br>放低要求<br>与妻子分担照顾孩子的工作</p>
</blockquote>
<p>家庭永远都应该被放在第一位。书中陈述了父亲在男孩成长过程中的重要性，所以不管工作轻松也好，真的很忙也罢，孩子需要父母（特别是父亲）的陪伴，而且应该在每个时间规划中，单独划出陪伴孩子的时间，多与孩子亲近和玩耍，才能是他健康快乐的成长。我们应该不仅仅是父母，更应该作为孩子最好的朋友之一。书中提到，有些儿童会患有ADD（注意力缺陷障碍），但有时候是因为父爱的确实而导致的。我们缺失应该与妻子分担照顾孩子的工作。我在妻子做月子的时候，下班回家后，我都会主动帮助她清洗奶瓶，整理宝宝需要用的东西，在喂完奶后，拍拍嗝，然后再哄睡。这一套下来，是真的累人，照顾孩子的工作，完全不亚于社会上的工作，甚至是有过之而无不及。所以也请体谅自己的妻子，也别把“挣钱”的自己，想的太伟大。</p>
<h3 id="男孩与听力"><a href="#男孩与听力" class="headerlink" title="男孩与听力"></a>男孩与听力</h3><blockquote>
<p>男孩时常会出现听力障碍，这是由于咽鼓管堵塞引起的。不管在家还是在学校，当孩子不听话时，一定要弄明白他们是不是没听到你对他们说的话。弄清这一点非常重要。</p>
</blockquote>
<p>我们在照顾孩子的头几个月就明白了一个道理，婴儿还那么小，他没有乖与不乖的分别，当他有需求的时候与我们唯一的沟通方式，就是哭，我们时常也会受不了无休止的哭闹，甚至还会发怒和抱怨，但你要知道，孩子哭闹一定是有他的原因的，父母应该多一些耐心，仔细观察，分析他是否有什么需求，或者是不舒服，找到原因后，为他解决问题或提供帮助，得到满足的小家伙，其实很快就会安静下来，过一会儿就喜笑颜开了。</p>
<h3 id="字、词、句"><a href="#字、词、句" class="headerlink" title="字、词、句"></a>字、词、句</h3><blockquote>
<p>在和孩子说话时，应高于他们的语言能力，但是只能高出一个层次。这样继续下去，孩子就能得到最大的提高。孩子喜欢这种游戏。所有人都喜欢交流。</p>
</blockquote>
<p>干货，与点线面一样的道理。在教孩子讲话的时候，可以按照这个方法循序渐进地提高孩子的语言能力。</p>
<h3 id="尽早给孩子读书"><a href="#尽早给孩子读书" class="headerlink" title="尽早给孩子读书"></a>尽早给孩子读书</h3><p>我和妻子都觉得应该为孩子养成阅读的习惯，而我们做父母的也应该以身作则，为家庭营造良好的阅读环境，放下手中的娱乐电子设备，大家一起投身知识的海洋。</p>
<h3 id="和孩子一起做些什么"><a href="#和孩子一起做些什么" class="headerlink" title="和孩子一起做些什么"></a>和孩子一起做些什么</h3><p>当孩子长大后，会发现和父母越来越疏远，有的心里话只愿意和自己最好的朋友倾诉，对，父母并没有成为孩子最好的朋友之一。<br>我和妻子都希望，如果我们的儿子需要帮助，或是有心事的时候，在他的倾诉对象中，我们作为父母的，会是他不错的选择。<br>当我们还是孩子的时候，应该或多或少会觉得，和自己的父母沟通会非常的尴尬和脸红，久而久之就越来越不想和父母聊一些自己的事情了。<br>其实和孩子聊天沟通，打成一片或许并不难。<br>我们可以和孩子一起做家务，一起挥动，与此同时可以聊一聊，我们的过去，聊一聊他的未来。总之，别尴聊，做点什么，变玩儿边聊，就变得顺畅又有意思了。</p>
<h3 id="自然结果和公正意识"><a href="#自然结果和公正意识" class="headerlink" title="自然结果和公正意识"></a>自然结果和公正意识</h3><blockquote>
<p>自然结果和公正意识，是你教育孩子的两大工具。只要是有关孩子的事，就一定要和他商量再决定。你绝不能强迫十几岁的孩子做他不愿意做的事。</p>
</blockquote>
<p>我自己的父母是比较传统的强势的那种，但是我和我的妻子的想法与我们的父母相比截然不同。我们认为孩子不是父母的附属品，没有必要事事听命于父母。和孩子有关的事情，他有权利为自己做决定，尽管我们知道，有些决定大概率会有不好的结果，但是我们应该作为意见的提出者，而不是为孩子强行决策，其实如果真的有些小挫折，对他也是一种成长和锻炼，有时候真的不能太“溺爱”孩子了。让孩子为自己的事情做决定，能够让他们拥有自己的主见和为后果负责的勇气，积极地面对未来的生活。</p>
<h3 id="性教育"><a href="#性教育" class="headerlink" title="性教育"></a>性教育</h3><p>父母主动为孩子提供应有的性教育应该是十分重要的。<br>我们应该教给孩子分辨喜欢、爱和色欲的不同，并告诉他一些有关性的知识，让他远离不健康的性行为，避免伤害别人，也避免受到伤害。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>当有了孩子的那一刻开始，生活就开始不一样了。<br>孩子学着长大，父母开始真正地成熟。<br>孩子也是独立的个体，我们应该学会倾听。<br>未来是美好而未知的，健康快乐比什么都重要❤️<br><br><br></p>
<hr>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdy9n09lgyj30bw0h4164.jpg" alt=""></p>
<h2 id="《白说》"><a href="#《白说》" class="headerlink" title="《白说》"></a>《白说》</h2><h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><blockquote>
<p>人生是一个围棋盘，当你读的书很少的时候，也就是这个棋盘上点的子很少，不成势，随时可能被别人吃掉。另外人找书书是很难的，但是书找书是非常容易的，越读书越知道该读什么书，书会带着你去读书，当你读了足够多了，这个围棋盘上的子连在一起，那它就会成势，人生就成势了。</p>
</blockquote>
<p>在阅读《白说》之前，已经读完了两本书，读书的目的是为了在书中能够学到可以在生活中运用的知识，或者说是干货。某天在逛B站的时候，看到了白岩松的一个片段，是关于对读书的看法（即上述引用），又从关联视频当中得知了《白说》这本书，就饶有兴趣地想去读一读。<br>我们这一代年轻人，应该都已经不怎么看电视了，就算打开电视，也都是听着声音玩手机玩电脑，而我一般打开电视就会转到新闻台，因为新闻台有说不完的话，也能顺便了解一下时事。</p>
<h3 id="代序"><a href="#代序" class="headerlink" title="代序"></a>代序</h3><blockquote>
<p>我姓白，所以这本书叫《白说》。其实，不管我姓什么，这本书都该叫《白说》。</p>
</blockquote>
<p>全书是作者整理总结了自己在各个地方的演讲稿所汇集的书，每个章节的最后还会附上自己的”读后感“，或者说称之为总结，个人觉得这体现了的一种严谨，既有助于读者的理解，还能让人拥有与作者交流的奇妙感觉。</p>
<blockquote>
<p>这个时代，误解传遍天下，理解寂静无声。即便你的整体节目本是为他们说话，但其中的一两句话没按他们期待的说，责难照样送上。后面跟过来责骂的人，大多连节目都没看过，看一两个网上的标题或一两条情绪化的微博就开始攻击。</p>
</blockquote>
<p>我基本赞同“被误解是表达者的宿命”这个观点，不同的人从不同的利益点出发，会对观点有不同的解读，甚至即便是毫无敌意的，帮助ta的人，也性所难免会被责备，人性的成长需要漫长的时间，但是我对人性依然有种渴望和信心，希望每个人为自己的言行负责，宽以待人，严于律己。</p>
<h3 id="做点无用的事儿"><a href="#做点无用的事儿" class="headerlink" title="做点无用的事儿"></a>做点无用的事儿</h3><blockquote>
<p>普京送的手机与法国人的度假</p>
</blockquote>
<p>俄罗斯有一种手机是双面屏幕的，一面是普通的手机屏幕，另一面跟Kindle一样，是电子墨屏幕。因为俄罗斯的人均阅读量在全世界是很靠前的。</p>
<blockquote>
<p>当一个民族持续二十多年都不读诗，甚至厌恶诗，把诗歌边缘化，你就知道我们生活中发生了什么样的问题。</p>
</blockquote>
<p>如今的生活节奏越来越快，在这个娱乐至死，流量至上的时代，无数次地刷低下线，快消文化从眼前不停地刷新又不停地消失，没有什么能在人们心上留下印记。也很少能有时间，在某个夜里，放松心情，浊酒赏月，发出”青天有月来几时百? 我今停杯一问之“的感叹。我认为诗词和歌曲是相对应的，当它们与场景和心境相互碰撞产生共鸣的时候，就是最美妙的时候。<br>到</p>
<h3 id="价值得失不是非有即无"><a href="#价值得失不是非有即无" class="headerlink" title="价值得失不是非有即无"></a>价值得失不是非有即无</h3><blockquote>
<p>每一本书中都蕴藏着你所期待的自己</p>
</blockquote>
<p>因为无知所以读书，越读书越觉得自己无知，就应该读更多的书，或许理想中的自己，是一个”完美到无法触及“的人，但是读书真的可以武装人，让自己越来越接近那个期待的自己，因为我们会从书中汲取养分，有的是自己渴望的养分，有的甚至是意想不到的养分。</p>
<h3 id="沟通世界不是非黑即白"><a href="#沟通世界不是非黑即白" class="headerlink" title="沟通世界不是非黑即白"></a>沟通世界不是非黑即白</h3><blockquote>
<p>八十年代的新闻专业，写导语讲究的是五个W：什么人（Who）、什么事（What）、什么时间（When）、什么地方（Where）、为什么（Why）</p>
</blockquote>
<p>不仅仅是新闻专业，我认为凡事都可以遵循明确五个W的原则，这五个W能够基本确定一件事情的总体大纲，言简意赅，又能够从其中的任意一个点进行延展，锦上添花。</p>
<h3 id="态度进退不是非取即舍"><a href="#态度进退不是非取即舍" class="headerlink" title="态度进退不是非取即舍"></a>态度进退不是非取即舍</h3><blockquote>
<p>涉及道德的问题，不应追问人们“有没有道德”，更应该思考的是，我们的社会环境、相关的法律制度，是否进步到了让人们“可以展现道德”的时候。中国人不缺德，缺的就是让“德”展现出来的制度保障与大环境。</p>
</blockquote>
<p>作者通过对比“交通事故交强险“和“扶摔倒老人被讹”两个事例分析“社会道德”问题，第一次看感觉角度和观点很新颖，也比较能接受。由此感悟：个人品德靠教育，社会品德靠制度。</p>
<blockquote>
<p>今年我常说的一句话是：“我们批评政府、批评党、批评社会不够进步，是不是也该批评一下自己？每一个公民都没问题，都是党和政府的问题，谁说的？党和政府什么时候让你闯红灯？什么时候让你用散步的速度在街上开车并乱加塞？”</p>
</blockquote>
<p>回想起自己大学的时候还是个愤青，会因为很多事情愤懑不满。随着时间的推移，看着祖国的发展和强大，一路有荣耀也有苦难，总来说，我的国，有我的家的感觉！尤其近期的新冠疫情，真的是举国之力救命于水火，大家也都很给力，配合和响应国家的号召，居家隔离减少外出，避免聚集性传染，徒增医疗负担。总体上，大家也是越来越团结的，或许我们的国家和政府还有很多不足，该说还是要说，同时，还是那句话“严于律己，宽以待人”，我们也要改正个体的缺点，使社会总体的水平走上新的台阶，才是有益于整个名族的进步。</p>
<blockquote>
<p>一味地宣传“大公无私”，鼓励“见义勇为”和“集体利益高于个人利益”，是扭曲的价值观。一个连自己都不爱的人，怎么会去爱别人、爱社会呢？反过来，只有当帮助别人成为自己的需求，而且是实实在在的需求时，公益、慈善、爱才真正具备了推动的基础，而不是作秀。</p>
</blockquote>
<p>请先爱己，及伴侣家人和朋友，再谈博爱。有些时候看着那些为了救助轻生的人，而献出自己生命的人的时候，真的是感到非常的惋惜。</p>
<h3 id="好医生一定会开“希望”这个配方"><a href="#好医生一定会开“希望”这个配方" class="headerlink" title="好医生一定会开“希望”这个配方"></a>好医生一定会开“希望”这个配方</h3><blockquote>
<p>三十年前的中国人，很多疾病是由于营养不良造成的，现在的疾病，尤其是慢性病，大多是由营养过剩造成的。</p>
</blockquote>
<p>中国近三十年的发展真的很快，特别是经济，快到很多其他方面都跟不上。三十年前，很多疾病是因为营养不良造成的，现在的疾病，大多是由营养过剩造成的，一前一后，一个是因为食不饱，另一个是因为是太饱（吃太饱，就会闲地）。</p>
<blockquote>
<p>尽管我爸两年后还是过世了，但是我妈在讲述这个故事的时候，安安静静地说：“如果遇上这样的医生，加上现在的技术，也许你爸的病就能治好了。”</p>
</blockquote>
<p>作者的父亲在他很小的时候因为疾病去世，虽然他们遇到了一位好医生，但是当时的医疗条件有限，所以非常可惜。<br>再谈谈如今，其实好医生还是会有，如今的医疗条件也好，但是医疗不是万能的，医疗也不是服务行业，患者真的别把自己当大爷，也没有包治百病，定能救活的医生，医疗只是为生命的延续增加可能，如果没有医疗，可能离死就更近了。社会，甚至制度应该给医疗更多的关注和庇护，严惩造成不良医患关系的始作俑者。</p>
<h3 id="时代真相不是非此即彼"><a href="#时代真相不是非此即彼" class="headerlink" title="时代真相不是非此即彼"></a>时代真相不是非此即彼</h3><blockquote>
<p>中国结束了挨打的时代、挨饿的时代，正在进入一个挨骂的时代。</p>
<p>为过去三十年在这块土地上成功过或失败过的人们，鼓一次掌。</p>
</blockquote>
<p>还记得2019年的10月1日那天，我坐着很早的高铁回家。火车上，信号不好，虽然断断续续地看着祖国70华诞阅兵仪式，但还是会忍不住感慨如今的国富民强，周围也有很多和我差不多年纪的人拿着手机也在看阅兵。上学那会儿老师总是笑说（九零后）是带过的最差的一届，而九零后也开始抗上时代的大旗案首阔步，不畏艰难。<br>过去的70年了，在这块土地上有过成功也有过失败，而失败应该像成功一样得到正视和认可，允许失败才能够促进创新，才能够距离成功更近一步。<br>感谢过去，在这块土地上成功过或失败过的人们。</p>
<blockquote>
<p>因此全世界很多媒体也在分析“为什么”。世界看中国的面孔，哪一张才是真的？事实上，如此错综复杂的面孔，就是世界看中国的面孔。未来十年，甚至很长的一段时间，中国都将面临这样的世界环境。不适应吗？要适应。</p>
</blockquote>
<p>中国现在面临着愈发复杂的外交环境，没办法做到邓小平爷爷说的“韬光养晦”。<br>外国现在看着我们所取得的成就，羡慕又不愿意承认我们的进步和强大。附和着老美诋毁我们以获取政治利益。他们不了解现在的中国，对于这些外行，要适应，用郭德纲的话讲就是，你正眼看他一下你就输了。（不包括应有的外交策略）</p>
<h3 id="时间轴上的中国"><a href="#时间轴上的中国" class="headerlink" title="时间轴上的中国"></a>时间轴上的中国</h3><blockquote>
<p>我仔细研究过十七大报告，关键字是“民”，前半本是民生，后半本是民主。报告用两个章节探讨民主的问题，尤其在党建部分，有很多很棒的说法。<br>比如，在党章修改里面，“上级任命”这四个字没有了。请各位去思考，取消“上级任命”这四个字意味着什么？党建部分有这样一句话：将来我们的领导干部是由党委推荐和群众推荐相结合，实行“票决制”。什么意思？这都是未来有关民主的某种粗框架模式的确立。<br>在十七大报告里，民主改革有了明确的时间表，叫“公民的有序参与”，先党内后党外，写得清清楚楚。我认为媒体在传播十七大报告的过程中是失职的，只强调了民生，几乎没强调民主。有关民主的报道也忽略了实现路径。</p>
</blockquote>
<p>中国的民主需要一写时间，就像市场经济体制的到来，它可能会迟到，但它迟早会来到。<br>我相信中国的民主也一定会具有我们中国的特色，和符合我们中国特色社会主义的国情需要的。</p>
<blockquote>
<p>有人说应该控制互联网上的谣言，务必谨慎，并合理合法。正如化疗在杀死癌细胞的同时也会杀死正常细胞，谣言被消灭了，真理也就跟着消失了。</p>
</blockquote>
<p>所有事情都是物极必反，具有两面性的。我原本觉得，互联网不应该成为法外之地，应该执行彻底的实名制，但是在某些时刻我们又希望通过匿名发声，想想着实还有些矛盾和悲凉啊。不过所谓言论自由都是相对的，从2019年的香港问题到2020年的新冠疫情，真是看足了好几场大戏，笑过骂过之后，还是安分做自己的事儿吧。</p>
<h3 id="中国梦"><a href="#中国梦" class="headerlink" title="中国梦"></a>中国梦</h3><blockquote>
<p>“很多很多年前，如果美国发生了这样的状况，也许中国人会感到很开心，‘你看，美国又糟糕了’。但是今天的中国人会格外地希望美国尽早好起来，因为我们有几千亿的钱在美国。”<br>我们还有大量产品等待着装上货船，送到美国来。如果美国的经济进一步转好，这些货品背后，就是一个又一个中国人增长的工资，是他重新拥有的就业岗位，以及家庭的幸福。</p>
</blockquote>
<p>中国梦已经从过去的国家梦成长为每个个体的梦想，可以让个体实现自我价值和理想，这在国家存亡之际都是不可能的，所以我们一直倡导和平和发展，因为中国深知战争的痛苦和危害。<br>在总体和平的今天，中美两个超级大国不大可能爆发大规模战争冲突，所以有冷战意味的贸易战就来了，就国力而言，美国确实还是世界第一，但中国人从来都不喜战，更不怕战…怎么写着写着，还激动起来了…<br>其实想说的是，在经济全球化的今天，这场危机的到来，没有谁可以独善其身，全身而退的，结局必定是两败俱伤的。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>《白说》这本书值得多读细读，<br>然后，或许，有些时候，应该静下心来多看看这个世界。</p>

      
      <!-- 打赏 -->
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/10/2020年4月读书心得/" data-id="ckevd2292000ekdbuuat9rrbk"
        class="article-share-link">分享</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/读书心得/">读书心得</a></li></ul>

    </footer>

  </div>

  

  

  

</article>
    
    <article id="post-2020年3月读书心得" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/04/03/2020年3月读书心得/"
    >2020年3月读书心得</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/04/03/2020年3月读书心得/" class="article-date">
  <time datetime="2020-04-03T06:28:14.000Z" itemprop="datePublished">2020-04-03</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/阅读/">阅读</a>
  </div>

      
      
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdgkfsmvgyj30u0146tpa.jpg" alt=""></p>
<h2 id="《富爸爸穷爸爸》"><a href="#《富爸爸穷爸爸》" class="headerlink" title="《富爸爸穷爸爸》"></a>《富爸爸穷爸爸》</h2><p>都说三十而立，我明年也就三十了。我们这代人，多“大器晚成”，因为没有太多生活的压力，面对如今这丰富的物质世界，挣钱慢，花钱快。<br>已经不记得是从哪个途径获取到《富爸爸穷爸爸》这这本书。读完它并没有对我接下来的“致富”有多大帮助，但是从书中却可以看到很多作者提出的“穷人”因何而穷的原因，在自己身上都会被对应到。<br>读罢本书，给我最大的收获是，重新确立自己的财富观和消费观。接下去，将从几个点，描述一下我从书中所得到的一些感受。</p>
<h3 id="专注自己的事业-正确的消费观"><a href="#专注自己的事业-正确的消费观" class="headerlink" title="专注自己的事业/正确的消费观"></a>专注自己的事业/正确的消费观</h3><blockquote>
<p>大多数人会冲动地用贷款去买新车或其他奢侈品，他们可能对生活有些厌烦了，所以期待有点新玩意儿。用贷款买奢侈品，结果迟早会让人们放弃那些东西，因为借下的债是个沉重的负担。<br>在你花时间投资并创建自己的事业之后，就准备好迎接那个富人的最大秘密吧。这个秘密铺平了富人的致富之路。</p>
</blockquote>
<p>回顾自己的生活，是不是和作者描述的极其相似？我们像“穷爸爸”一样，日复一日地努力上班，为的是每个月那固定时间固定金额的工资，我们用他支付房租，支付每顿饭，甚至我们都拿不到全部的金额，因为我们还需要交税，女孩们或许还需要购买一些化妆品，男孩们想想应该买鞋了，这些都是日常生活里的“基本开销”。偶尔对生活和工作的“压力”有些不满，想要购买一些早就心仪已久的“奢侈品”（展开可以理解成价格不菲的电子产品或名牌包包），这是无可厚非的，平凡的日子里需要一些新鲜玩意儿刺激一下。但是，我们更多的支付方式是什么？望着手头本就不宽裕的现金，更可能会选择花呗、信用卡、甚至分期付款，动用未来的钱，让自己背上一个个负债。<br>而“富人”的选择是，现金的存是资产增值的保障，他们会使用现金去购买资产，通过资产去挣取收益，而通过收益的部分金额作为奖励全额购买“奢侈品”。<br>对此，我思考了以往的生活消费方式，对于一些金额“小高”的商品，我会选择存一小段时间的钱以后，全额购买；而对于金额“较高”，而我有基于想要的商品，毫无悬念地会选择分期付款的。<br>是时候对现有的消费观进行修正了，我们努力工作，是为了让生活变得更好，每个人都应该去“创业”，这并不是说让大家毅然决然地辞去现在还能有收入的工作，而投身去不稳定的创业中去，而是当今我们所说的“副业”，找一个自己喜欢的，擅长的，甚至是自己早就想干的事业，全身心地投入其中，努力让“副业”产生现金流。当“副业”有了一定规模，拥有了一定团队规模，它就能够成为我们的资产，而资产能够产生较为稳定的现金，是不是就离财务自由更进了一步。</p>
<h3 id="资产"><a href="#资产" class="headerlink" title="资产"></a>资产</h3><blockquote>
<p>资产就是能把钱放进你口袋里的东西＆负债是把钱从你口袋里取走的东西。</p>
<p>资产举例：<br>一、不需我到场就可以正常运作的业务<br>二、股票、基金、债券<br>三、产生收入的房地产<br>四、专利权和著作权<br>五、任何其它有价值、可产生收入或增值并且有很好的流通市场的东西<br>六、知识</p>
<p>负债举例：<br>一、维持生存：食、衣、住、行<br>二、健康问题：亚健康、医院、药物<br>三、休闲娱乐：出游、旅行、餐宴、活动<br>四、法令规定：税务、手续费、规费<br>五、额外开销：罚单、社交、补遗<br>六、资金借贷：贷款、信用卡、私人借款</p>
</blockquote>
<p>作者在书中反复强调应该增加资产，减少负债。因为资产能够增加现金流，也就是为我们挣钱。而尽量减少负债，能够让我们维持手中尽量过的资金，而资金可以用来投资（钱生钱）或储蓄（我认为一定量的储蓄是必要的）。同时，我们应该养成一个良好的习惯，那就是利用创造的收入去消费，特别是大额消费，而避免所以动用储蓄。</p>
<h3 id="风险与收益"><a href="#风险与收益" class="headerlink" title="风险与收益"></a>风险与收益</h3><blockquote>
<p>“保险”的投资尝尝过于安全，太安全则会导致低收益。</p>
</blockquote>
<p>高风险，高回报；低风险，低收益。<br>风险与收益成正比，是一个所有人都明白的道理。<br>将钱存在银行里，或者购买一些风险低收益稳定的基金，属于“低风险”的投资。<br>而创业、投资股票这类，我认为是”高风险“的投资。<br>我认为，每个人都值得为自己建立一份事业，这里的事业不是指上班的工作，而是实实在在的自己当”老板“，且不论规模大小，当这份事业有了一定的收入，那它就能成为我们的资产。<br>当然，高风险以为着失败后，所要承受的后果，也会比低风险的投资要大。所以，投入高风险投资前，需要具备尽量多的专业知识，避免采坑，将风险发生的可能性降低，同时还要有乐观迎接失败的心态。失败并不代表一无所获，可以收获经验，我们应该尽量早地去”试错“和”失败“，因为当我们还年轻的时候，我们有更高的抗风险能力，容错能力。</p>
<h3 id="试着付诸实践"><a href="#试着付诸实践" class="headerlink" title="试着付诸实践"></a>试着付诸实践</h3><blockquote>
<p>在周末研讨班学习”如何购买破产的房地产“时，我学会了一个模式，那就是试着付诸实践，而这一步正式许多人没能做到的。</p>
</blockquote>
<p>学到的知识，如果不去实践，那就永远不会成为自己的能力。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>《富爸爸穷爸爸》这本书给我的最大帮助是确立正确的消费观——不要用储蓄去支付”奢侈品“，而是应该通过学习专业知识，用以购买或获取良性资产，降低风险，让资产为自己工作。</p>

      
      <!-- 打赏 -->
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/03/2020年3月读书心得/" data-id="ckevd228x0008kdbuc5n33pgm"
        class="article-share-link">分享</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/读书心得/">读书心得</a></li></ul>

    </footer>

  </div>

  

  

  

</article>
    
    <article id="post-LeetCode算法学习日记（2020年3月）" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/24/LeetCode算法学习日记（2020年3月）/"
    >LeetCode算法学习日记（2020年3月）</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/24/LeetCode算法学习日记（2020年3月）/" class="article-date">
  <time datetime="2020-03-24T07:55:37.000Z" itemprop="datePublished">2020-03-24</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/算法/">算法</a>
  </div>

      
      
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h3 id="2020-3-23"><a href="#2020-3-23" class="headerlink" title="2020.3.23"></a>2020.3.23</h3><hr>
<p><b>题目：</b>求两数的最大公约数<br><b>知识点：</b>辗转相除法（欧几里得算法）<br><b>代码：</b><br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">getGreatestCommonDivisor</span><span class="params">(x : Int, y : Int)</span></span> -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> preDivisor = <span class="built_in">max</span>(x, y)</span><br><span class="line">        <span class="keyword">var</span> <span class="type">Divisor</span> = <span class="built_in">min</span>(x, y)</span><br><span class="line">        <span class="keyword">repeat</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="type">Remainder</span> = preDivisor%<span class="type">Divisor</span></span><br><span class="line">            <span class="keyword">if</span> <span class="type">Remainder</span> == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            preDivisor = <span class="type">Divisor</span></span><br><span class="line">            <span class="type">Divisor</span> = <span class="type">Remainder</span></span><br><span class="line">        &#125;<span class="keyword">while</span> <span class="literal">true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="type">Divisor</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><b>算法理解：</b><br>假设x &gt; y，则有x = k·y + r（x，y，k，r都为正整数，且r≥0）<br>当r = 0，y为(x, y)<br>当r &gt; 0，r = x%y = x - k·y<br>假设d为(x, y)的公约数，记做 <code>d|x</code>（x能够被d整除）和 <code>d|y</code>（y能够被d整除）<br>则以上等式可以写成r/d = x/d - k·y/d，而等式的右边一定是正整数，所以r也能被d整除，即记做 <code>d|r</code><br>所以x, y, x%y具有相同的公约数集<br>同理可得x_0 = y, y_0 = x%y, r_0 = x_0 % y_0 = y%(x%y)具有相同的公约数集，并以此类推<br>当首次出现x_n%y_n = 0时，即为(x, y)的最大公约数</p>
<h3 id="2020-3-24"><a href="#2020-3-24" class="headerlink" title="2020.3.24"></a>2020.3.24</h3><hr>
<p><b>题目：</b>【水壶问题】有两个容量分别为 x升 和 y升 的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 z升 的水？<br>如果可以，最后请用以上水壶中的一或两个来盛放取得的 z升 水。<br>允许操作：<br><b>·</b> 装满任意一个水壶<br><b>·</b> 清空任意一个水壶<br><b>·</b> 从一个水壶向另外一个水壶倒水，直到装满或者倒空<br><b>知识点：</b>裴蜀定理（贝祖定理）<br><b>代码：</b><br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">gcd</span><span class="params">(<span class="number">_</span> x : Int,<span class="number">_</span> y : Int)</span></span> -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> preDivisor = <span class="built_in">max</span>(x, y)</span><br><span class="line">        <span class="keyword">let</span> <span class="type">Divisor</span> = <span class="built_in">min</span>(x, y)</span><br><span class="line">        <span class="keyword">if</span> preDivisor % <span class="type">Divisor</span> == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Divisor</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> gcd(x: <span class="type">Divisor</span>, y: preDivisor % <span class="type">Divisor</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">canMeasureWater</span><span class="params">(<span class="number">_</span> x: Int, <span class="number">_</span> y: Int, <span class="number">_</span> z: Int)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> z &gt; x+y&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> x==<span class="number">0</span> || y==<span class="number">0</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (z==<span class="number">0</span>) || (x+y==z)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> z % gcd(x, y) == <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><b>算法理解：</b><br>由题可知，在z ≤ x+y，且x, y都不为0的情况下，两个水壶总水量的增加或减少，一定有至少一个壶是满的或是空的，不存在同时有水且都不满的情况。<br>当有一个水壶不满时，往不满的水壶里加满水，或是将水壶倒空，都是没有意义的，<br>所以，每次变动的 <code>总水量</code> 一定是 x 和 y 的变化量。<br>此时题目可以理解为 <code>总水量</code> 经过a次 x升，b次 y升 的变化，能否最终得到 z升？<br>也就获得了等式：</p>
<center>ax + by = z</center>

<p>而只要满足 z ≤ x+y，且这样的 a, b 存在，那么目标就可以达成。<br>根据 <a href="https://baike.baidu.com/item/%E8%A3%B4%E8%9C%80%E5%AE%9A%E7%90%86/5186593" target="_blank" rel="noopener">裴蜀定理(贝祖定理)</a>，ax+by = z 有解的充要条件是：当且仅当 z 是 (x, y) 最大的公约数的倍数。<br>因此我们只需要找到 (x, y) 的最大公约数并判断 z 是否是它的倍数即可。</p>

      
      <!-- 打赏 -->
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/24/LeetCode算法学习日记（2020年3月）/" data-id="ckevd2297000mkdbuy8dqz10u"
        class="article-share-link">分享</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LeetCode/">LeetCode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Swift/">Swift</a></li></ul>

    </footer>

  </div>

  

  

  

</article>
    
  </article>
  

  
  <nav class="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        &copy;
        2018-2020
        GG266
      </li>
      <li>
        
          Powered by
        
        
        <a href="https://hexo.io" target="_blank">Hexo</a> Theme <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul class="list-inline">
      <li>
        
        
        <ul class="list-inline">
  <li>PV:<span id="busuanzi_value_page_pv"></span></li>
  <li>UV:<span id="busuanzi_value_site_uv"></span></li>
</ul>
        
      </li>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s4.cnzz.com/z_stat.php?id=1278583018&amp;web_id=1278583018'></script>
        
      </li>
    </ul>
  </div>
</footer>
    <div class="to_top">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>
      </div>
    </main>
    
      <aside class="sidebar">
        
        <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/avatar.svg" alt="GG266的个人博客"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
      </aside>
      <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
      <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.justifiedGallery.min.js"></script>
<script src="/js/lazyload.min.js"></script>
<script src="/js/busuanzi-2.3.pure.min.js"></script>




<script>
  var ayerConfig = {
    mathjax: false
  }
</script>

<script src="/js/ayer.js"></script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">



<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>
  
  

  </div>
</body>

</html>