<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
    
  <meta name="description" content="iOS coder,Machine-learning,DJ Hong的个人博客" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     GG266的个人博客
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/favicon.jpg" />
  
  <link rel="stylesheet" href="/css/style.css">
  <script src="/js/pace.min.js"></script>

  

  

</head>

</html>

<body>
  <div id="app">
    <main class="content">
      
<div id="main">
  <section class="outer">
  <article class="articles">
    
    
    
    
    <article id="post-2020年10月读书心得" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/10/17/2020年10月读书心得/"
    >2020年10月读书心得</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/10/17/2020年10月读书心得/" class="article-date">
  <time datetime="2020-10-17T13:38:08.000Z" itemprop="datePublished">2020-10-17</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/阅读/">阅读</a>
  </div>

      
      
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p><img src="https://sinastorage.com/storage.caitou.sina.com.cn/products/201611/a2fa9be2b6878c81d81b85b26f391efe.jpeg" width="400" align="center"></p>
<p>这本书主要描述了马斯克的几段创业史，即早期的从事企业信息上网的Zip2和支付系统PayPal，还有历尽重重困难现在终于成功的太空运输公司SpaceX和纯电动车公司Tesla。书中最有意思的部分就是马斯克在创业时遇到的痛苦和磨难，和他如何去解决这些问题的过程。他从不吝啬将挣到的钱又再次地投入到他梦想的事业中去，同时为此疯狂地工作，并要求其他人像自己一样努力工作，甚至放弃和亲友的相聚时光。成功是需要代价的，但我不认为牺牲和家人的时间是必须的。但是，马斯克那种工作劲头和面对任何困难都毫不放弃的决心，只为实现一个疯狂的梦想是值得人学习的。<br>SpaceX公司创立于2002年，2008年获得NASA的正式合同，直到2012年花了10年十年终于成功地为国际空间站输送货物。这十年内，SpaceX无数次濒临破产，航空业的每一次实验成本都是一个天文数字，更何况是在SpaceX完成火箭回收技术之前，并且它还是一家私营的公司。2020年5月31日，SpaceX将两名宇航员成功送入国际空间站并回收火箭，标志着其成为了第一家实现载人航天的商业公司！<br>而几乎是相同的时间，马斯克还管理运营着Tesla电动汽车公司，而不管造火箭还是造车，马斯克都毫不妥协，他不相信供应商的工作效率和积极性，所以核心零件都由公司自主研发制造，掌握关键技术，并有效控制成本。Tesla还“颠覆”了传统汽车销售模式，采用直销的方式，除了希望带给消费者实惠以外，还有实实在在的服务和便利。这些都是Tesla的企业愿景，具体如何，Tesla车主们应该更有发言权。但从目前的市场情况来讲，将Tesla比作类似于苹果的消费电子类产品，已经一点也不为过了。<br>站在相对于本书的未来角度，看着SpaceX和Tesla历经磨难一步步地走到今天，确实还是挺心潮澎湃的。</p>
<hr>
<p><img src="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=2645023494,2477502673&fm=15&gp=0.jpg" width="300" align="center"></p>
<p>中国历史上第一个实现大一统的秦国，仅仅建立14年，就被推翻，后由汉高祖刘邦称帝建立新朝——西汉。<br>西汉的发展可以说是在对的时间出现了对的人，文、景、武、宣四个皇帝，都是在最合适的时机登场，并取得了影响后世的历史成就。西汉极盛时，疆域东并朝鲜、南据交趾、西逾葱岭、北抵大漠，国富民强，在疆域、政治、军事、经济、文化、民族和外交上皆有建树。只可惜汉宣帝之后，从汉元帝开始的皇帝，一蟹不如一蟹，最终使汉朝一步步走向衰退。<br>《盛世：西汉》这本是引用了详实的史料（多出于《史记》）对西汉盛世进行描写，且不说作者自身观点如何，但从对历史的描述来说，阅读此书给我的感觉用两个字描述足以——过瘾，非常值得一读。</p>
<hr>
<p><img src="http://n.sinaimg.cn/translate/56/w470h386/20190327/1d77-hutwezh0815631.jpg" width="400" align="center"></p>
<p>《能力陷阱》这本书主要讲的是如何提升自己的领导力，而我在阅读次书的时候，将其视为如何提升自己的“外在”能力。所谓的外在能力，我的理解是那些，我们并不擅长的，亦或是我们还不知道的一些能力。与其对应的，当然就是所谓的“内在能力”，内在能力指的是，我们已经掌握的、擅长做的事情的能力。能力陷阱的体现之处就在于，我们都喜欢做那些我们擅长的事，它会让我们非常有成就感，越有这种感觉，我们就越乐意做这件事，使得我们就越擅长做这件事，注意到了吗，这是一个“可怕”的循环。如果没有及时意识到这点，就会被这个“陷阱”套住，而限制了其他能力的发展。有时候，我们总是在做我们“想做”的事情，而忽略了“应该”做的事情。而“应该”做的事情，可能是我们能力外的，这样我们便损失了可以锻炼提升“外在”能力的机会。</p>
<p>有些人可能会说，做自己“喜欢”的事情，是忠于真实的自己。但大家都忽略了一个非常重要的问题：每个人都有多面性，都有多个“自己”。而你要忠于的是哪一个自己？</p>
<p>我认为如此地“忠于自己”，是一种安于舒适圈的借口。</p>
<h4 id="人的一生都在不停地改变"><a href="#人的一生都在不停地改变" class="headerlink" title="人的一生都在不停地改变"></a>人的一生都在不停地改变</h4><blockquote>
<p>心理学家丹尼尔·赖文森（Daniel Levinson）提出了著名的“七年之痒”（Seven-year Itch）的概念。他的研究发现改变可能会循环发生，“稳定”与“改变”两个时期总是不断地在生活里交替发生。</p>
</blockquote>
<p>“稳定”期通常能维持的时间是7年，当然这并不是说7年内不会有任何改变（我们总是在不断地变化），这里的稳定是相对的。这段时期内，我们的任务就是完成各项“计划”。</p>
<p>但一段时间以后，我们会发现有些事并不像我们所计划的那样发展。或许是因为环境变了，而我们的能力却还没有跟上环境的变化，此时便会萌发出一种情绪——焦虑。</p>
<p>“焦虑”的情绪会驱使着我们去“改变”，“改变”期通常持续的时间是三年，在这个时期内，我们需要重新思考自己所做的事，还要思考做这些是的目的。成年人的世界，充满了各种选择和诱惑，我们需要分辨出做什么事情，对自己更有“意义”。</p>
<p>我个人的心得是，面对不断变化的环境，先不要考虑自己的能力问题（因为能力陷阱），然后去选择自己认为有发展前景的事情，去做实现它“应该”做的事，如果这件事有困难，那么恭喜自己，首先不管结果如何，我们都将收货些什么，以此来提升我们的”外在“能力。</p>
<p>”外在“能力的提升，需要我们去实践和验证，而不是一个人坐在安静的地方连续思考3个小时！</p>

      
      <!-- 打赏 -->
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/10/17/2020年10月读书心得/" data-id="ckgx5nsf300060gbumugnhlxv"
        class="article-share-link">分享</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/读书心得/">读书心得</a></li></ul>

    </footer>

  </div>

  

  

  

</article>
    
    <article id="post-2020年9月读书心得" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/09/26/2020年9月读书心得/"
    >2020年9月读书心得</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/09/26/2020年9月读书心得/" class="article-date">
  <time datetime="2020-09-26T11:58:23.000Z" itemprop="datePublished">2020-09-26</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/阅读/">阅读</a>
  </div>

      
      
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p><img src="https://pic3.zhimg.com/50/v2-4a61951300349f07efb8391af6495855_720w.jpg" alt=""></p>
<p>一直以来觉自己读书没有什么章法，每次阅读都是毫无目的的一行一行浏览，这样的阅读方法会让我非常容易走神，并且吃不进书的内容。早些时候，因为听过《樊登读书会》的一些音频，感觉樊登对一本书的内容理解和讲述地还不错，即表达清楚了书的内容，又有自己的见解。以《清单革命》这本书为例，我是先停了樊登读书的音频版本，再去读的这本书，结果是阅读这本书让我感觉非常地枯燥和范围，但是音频版本确实不错，值得一听，也是从那时候起，我自己开始使用清单App对日常的生活工作，进行管理备忘和安排。<br>好像扯远了…<br>读完这本书，让我了解到，樊登在读书的时候，会将自己安置在一个安静的地方，这样的环境可以保证在看书的时候能够全身心地投入。接着在看书之前，设置一个阅读的框架：</p>
<blockquote>
<ul>
<li>这本书的使命是什么？</li>
<li>为了解决什么问题？</li>
<li>为了达成使命，或解决问题，提出哪些假设？</li>
<li>提出解决方案。</li>
<li>如何论证这些假设和方案的有效性？</li>
<li>最后得出了什么结论？</li>
<li>这些结论对我们的意义是什么？</li>
</ul>
</blockquote>
<p>然后，带着这些问题到书里去寻找答案。在读罢一本书之后，樊登的做法是静下心来回忆一遍书里的内容，将核心点梳理和复盘成思维导图，再通过语言组织，在尽肯能保证原意的基础上，用自己的方式进行表述。</p>
<p>能够总结出这样的框架，并拥有极强的专注力，记忆力和表达能力，可能要得益于樊登的辩论经历和刻意练习。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>我一直都希望能够有一个系统的读书方法，而本书对我的帮助在于两点。<br>第一是在读书之前应建立大局观。我会在读完一本我认为颇有收获的书之后，写上一篇读书笔记（心得）。这第二就是再创作，读书笔记就是再创作。在陈述一本书的内容时，通过自己的方式，既要表达出自己的观点和理解，又不能脱离其核心观点和原貌。<br><br><br></p>
<hr>
<p><img src="https://nimg.ws.126.net/?url=http%3A%2F%2Fspider.ws.126.net%2Fe4ae946c641e4872b0de6cae042985d0.jpeg&amp;thumbnail=650x2147483647&amp;quality=80&amp;type=jpg" alt=""></p>
<h4 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h4><p>《认知天性》这本书，是在阅读《读懂一本书：樊登读书法》的内容中，偶然发现的，我带着能够获取一些学习方法的心态和目的阅读了这本书，结果是效果还不错，至少不会让我觉得枯燥。</p>
<h4 id="学习是挑战天性的必修课"><a href="#学习是挑战天性的必修课" class="headerlink" title="学习是挑战天性的必修课"></a>学习是挑战天性的必修课</h4><p>本事开篇就抛出了一个人们在学习这件事情上的认知错误，那就是人们总是觉得对知识点的反复阅读能够提升它的记忆，并错误的觉得自己已经掌握了知识点。但是，通过对比实验可以证明，反复阅读记忆对掌握知识点其实没有太大的帮助。<br>而需要通过“考试”（或“测试”）这种检索式的学习方法，从反馈中了解对知识的掌握情况，再进行有针对性的刻意练习，方为行之有效的学习方法。</p>
<h4 id="学习的本质-amp-“后刻意练习”时代"><a href="#学习的本质-amp-“后刻意练习”时代" class="headerlink" title="学习的本质 &amp; “后刻意练习”时代"></a>学习的本质 &amp; “后刻意练习”时代</h4><blockquote>
<p>练习从记忆中检索新知识或新技能是有效的学习工具。</p>
</blockquote>
<p>大脑的检索与反复阅读相比，它是有一定意义的思考方式。反复阅读可以理解成是对知识的输入，它带来的流畅感，会给人掌握的错觉。而检索记忆则是通过不同题目、不同场景去考察对知识的掌握度，是一种输出，是一种对掌握能力的反馈，同时还“强迫性”地带动大脑的运转。当知识检索成为了习惯，就可以成为一种条件反射，大大提高解决问题的效率和正确率。</p>
<blockquote>
<p>有间隔、有内容穿插出现，以及内容多样化，其实就是我们生活的本来面貌。</p>
</blockquote>
<p>但是知识检索这种练习，也很容易进入和反复阅读一样的认知误区，那就是集中练习相同的知识或能力，人们总是觉得熟能生巧，但其实可能只是产生了短期记忆，并且如果遇到稍有不同的问题，可能就没法解决了。所以，作者在文中提倡进行有间隔的、有穿插的、具有多样性的练习。这样练习的目的是因为，我们生活中的问题往往是不经意的、没有顺序的出现，问题它不会像我们学习知识一样，反复地有序地按照我们学习的顺序出现。而穿插练习和多样化练习便是根据这个特点应运而生的学习方法，它能帮助我们更好地学习评估问题的背景，以及辨别问题间的差异，再从我们的知识储备中检索最合适的解决方案。最后通过对结果的反思，找出不足，重点学习，做到对知识掌握的巩固和提升。</p>
<h4 id="知识的“滚雪球”效应"><a href="#知识的“滚雪球”效应" class="headerlink" title="知识的“滚雪球”效应"></a>知识的“滚雪球”效应</h4><blockquote>
<p>学习的的三个步骤：心理学家将学习/记忆过程中的三个阶段分为：编码（获得信息）、存储（将信息维持一段时间）、检索（以后使用信息）。</p>
</blockquote>
<p>学习是一个编码（获取），巩固（存储），检索（运用）的过程。已经掌握的知识会形成一条检索路径，当遇到合适场景的时候，能通过一些关键点，检索到对应的知识点。通过有间隔地，穿插式的学习方法，可以避免反复练习造成的麻痹和错觉，更好地对知识点进行区分，建立心智模型。而通过多样化的方式，对知识进行测试，则是通过不同的现实场景，结合关联关键知识点，锻炼和构建检索路径，使得对知识的掌握和运用更加地灵活。在学习的过程中，我们应该趋向于有难度的练习和自主的学习方式，这有助于强化自己的辨析和归纳能力，并且我们应该不惧犯错，通过有效合理的纠正性反馈，能收获更好的学习效果。</p>
<h4 id="心智模型"><a href="#心智模型" class="headerlink" title="心智模型"></a>心智模型</h4><blockquote>
<p>掌握了生活中方方面面的知识，我们会倾向于把做事的步骤集合在一起来解决各种问题。</p>
</blockquote>
<p>由于直觉式的元认知，人们总是会对自身给出高于实际的评估分数，这种认知甚至衍生到了对周遭的理解上，人们会想方设法用自己熟悉的自认为理性的方式来诠释身边发生的事情。这在很大程度上给我们提供了错误的认知和影响了我们的判断能力。而我们需要做的，应该是有意识地分析和推理，并进行自我控制，建立自己的心智模型（将知识集合成解决问题的步骤），通过实践和测验，去发现学习的漏洞，并把它填补完整。</p>
<h4 id="学习风格"><a href="#学习风格" class="headerlink" title="学习风格"></a>学习风格</h4><blockquote>
<p>分析型智力是我们解决问题的能力，典型的例子就是解答测验中的问题；<br>创新型智力是我们综合并应用现有的知识与技能，应对那些新的特殊情况的能力；<br>实践型智力是我们适应日常生活的能力;</p>
</blockquote>
<p>构建适合自己的学习风格，首先要求我们能掌控学习的主动性，利用动态的测验方法，找到自己对于某种知识和技能的缺失，从而进行改善。同时，我们还需要根据不同的文化和学习场景锻炼和运用不同的智力类型（分析型，实践型，创新型），并通过实践去提取其中的原则，构建心智模型的结构，最终成为可以使自己在实际问题中可以捷足先登的诀窍。</p>
<h4 id="终生学习"><a href="#终生学习" class="headerlink" title="终生学习"></a>终生学习</h4><blockquote>
<p>智商测验一直被用来衡量个人的逻辑与语言潜能。这类测验会规定一个智力商数，代表心理年龄与实际年龄的比率，然后再乘以100得出智商值。</p>
</blockquote>
<p>智力水平（也就是我们常说的“智商”）是一种可以通过努力提高的能力，而我们努力的目标和方向应该是为了学到新的知识或技能。在成长的过程中，优秀的执行力甚至比学习技巧更加重要，我们需要通过刻意练习和反复应用，让知识扎根于我们的潜意识之中。</p>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>学习和提升一定是一个艰辛、痛苦，且见效慢的过程，永远不要让自己长时间处于舒适的状态中，居安思危，不断挑战自己，才能获得成长。</p>

      
      <!-- 打赏 -->
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/09/26/2020年9月读书心得/" data-id="ckgx5nsfh000u0gbu3adx3vqe"
        class="article-share-link">分享</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/读书心得/">读书心得</a></li></ul>

    </footer>

  </div>

  

  

  

</article>
    
    <article id="post-iOS源码阅读 —— YYModel  vs  MJExtension" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/09/14/iOS源码阅读 —— YYModel  vs  MJExtension/"
    >iOS源码阅读 —— YYModel  vs  MJExtension</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/09/14/iOS源码阅读 —— YYModel  vs  MJExtension/" class="article-date">
  <time datetime="2020-09-14T12:13:12.000Z" itemprop="datePublished">2020-09-14</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

      
      
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p><code>YYModel</code>和<code>MJExtension</code>作为JSON模型转换工具，应该算是国内使用者比较多的第三方框架。相信两款都用过的开发者大有人在，我也是其中之一。既然如此，笔者便相继阅读了这两个库的主要源码，并参考<code>YYModel</code>作者<a href="https://blog.ibireme.com/" target="_blank" rel="noopener">ibireme</a>的<a href="https://blog.ibireme.com/2015/10/23/ios_model_framework_benchmark/" target="_blank" rel="noopener">《iOS JSON 模型转换库评测》</a>一文进行了的评测和展开。本文仅代表个人观点，如有异议，欢迎交流指导。</p>
<h3 id="评测对象"><a href="#评测对象" class="headerlink" title="评测对象"></a>评测对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pod &apos;YYModel&apos;, &apos;~&gt; 1.0.4&apos;</span><br><span class="line"></span><br><span class="line">pod &apos;MJExtension&apos;, &apos;~&gt; 3.2.2&apos;</span><br></pre></td></tr></table></figure>
<p>评测用例：<a href="https://github.com/a334713698/JSONModelTransformReview/tree/master/JSONModelTransformReview/GithubUserModel/user.json" target="_blank" rel="noopener">GithubUser</a>、<a href="https://github.com/a334713698/JSONModelTransformReview/tree/master/JSONModelTransformReview/WeiboModel/weibo.json" target="_blank" rel="noopener">WeiboStatus</a><br>评测代码：<a href="https://github.com/a334713698/JSONModelTransformReview" target="_blank" rel="noopener">https://github.com/a334713698/JSONModelTransformReview</a><br>运行环境：iOS 13.5 | iPhone XS Max</p>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>性能评测的方法是两个库执行相同次数的JSON模型转换，对比二者的耗时情况。</p>
<h4 id="用例1：GithubUser"><a href="#用例1：GithubUser" class="headerlink" title="用例1：GithubUser"></a>用例1：GithubUser</h4><p><code>GithubUser</code>的数据主要类型是string，和少量的number，主要测试转换库的基本功能。<br>我们分三遍执行两个转换库的相关方法，每遍执行<u><strong>50000</strong></u>次，统计耗时毫秒数。<br>结果如下：</p>
<table>
<thead>
<tr>
<th>Json 2 Model</th>
<th>第一次</th>
<th>第二次</th>
<th>第三次</th>
<th>遍历次数</th>
</tr>
</thead>
<tbody>
<tr>
<td>MJExtension</td>
<td>1481.25 ms</td>
<td>1468.86 ms</td>
<td>1452.77 ms</td>
<td>1,550,000</td>
</tr>
<tr>
<td>YYModel</td>
<td>257.29 ms</td>
<td>250.48 ms</td>
<td>250.39 ms</td>
<td>1,400,000</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Model 2 Json</th>
<th>第一次</th>
<th>第二次</th>
<th>第三次</th>
<th>遍历次数</th>
</tr>
</thead>
<tbody>
<tr>
<td>MJExtension</td>
<td>1182.23 ms</td>
<td>1162.47 ms</td>
<td>1173.69 ms</td>
<td>1,550,000</td>
</tr>
<tr>
<td>YYModel</td>
<td>382.40 ms</td>
<td>373.91 ms</td>
<td>379.84 ms</td>
<td>1,300,000</td>
</tr>
</tbody>
</table>
<h4 id="用例2：WeiboStatus"><a href="#用例2：WeiboStatus" class="headerlink" title="用例2：WeiboStatus"></a>用例2：WeiboStatus</h4><p>微博数据<code>WeiboStatus</code>包含大量的复杂类型，主要测试转换库在复杂数据类型情况下的性能。<br>我们分三遍执行这个方法，每遍执行<u><strong>5000</strong></u>次，统计耗时毫秒数。<br>结果如下：</p>
<table>
<thead>
<tr>
<th>Json 2 Model</th>
<th>第一遍</th>
<th>第二遍</th>
<th>第三遍</th>
<th>遍历次数</th>
</tr>
</thead>
<tbody>
<tr>
<td>MJExtension</td>
<td>4061.77 ms</td>
<td>4054.89 ms</td>
<td>4057.63 ms</td>
<td>2,290,000</td>
</tr>
<tr>
<td>YYModel</td>
<td>813.44 ms</td>
<td>803.64 ms</td>
<td>806.97 ms</td>
<td>2,285,000</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Model 2 Json</th>
<th>第一遍</th>
<th>第二遍</th>
<th>第三遍</th>
<th>遍历次数</th>
</tr>
</thead>
<tbody>
<tr>
<td>MJExtension</td>
<td>596.46 ms</td>
<td>592.42 ms</td>
<td>589.69 ms</td>
<td>475,000</td>
</tr>
<tr>
<td>YYModel</td>
<td>660.04 ms</td>
<td>626.69 ms</td>
<td>615.30 ms</td>
<td>1,215,000</td>
</tr>
</tbody>
</table>
<h4 id="性能评测结果"><a href="#性能评测结果" class="headerlink" title="性能评测结果"></a>性能评测结果</h4><ul>
<li>每个用例的第一遍评测，都会比后两遍有稍多的用时，是因为第一遍运行，会首次创建和缓存类的类元信息和属性元信息，后两遍再运行的时候，可以直接使用缓存，减少重复生成类元和属性元造成的开销。</li>
<li>系统方法和容器使用方面：<code>MJExtension</code>主要使用的是Foundation框架的NSArray、NSDictionary，以及KVC的方法进行取值和赋值。<code>YYModel</code>主要使用了CoreFoundation框架的容器和遍历方法，通过<code>objc_msgSend</code>消息发送的方式，调用属性的<code>_setter</code>和<code>_getter</code>进行取值和赋值，部分地方还使用inline和纯C函数。</li>
</ul>
<h3 id="容错"><a href="#容错" class="headerlink" title="容错"></a>容错</h3><p>容错性主要是测试，当JSON和Model之间的数据格式不完全相同时，转换库是如何处理的，是否会产生错误或造成Crash。</p>
<table>
<thead>
<tr>
<th>用例 1</th>
<th>JSON属性是：数值，Model属性是：NSString</th>
</tr>
</thead>
<tbody>
<tr>
<td>MJExtension</td>
<td>100 -&gt; @”100”</td>
</tr>
<tr>
<td>YYModel</td>
<td>100 -&gt; @”100”</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>用例 2</th>
<th>JSON属性是：数值字符串，Model属性是数值</th>
</tr>
</thead>
<tbody>
<tr>
<td>MJExtension</td>
<td>@”100” -&gt; 100</td>
</tr>
<tr>
<td>YYModel</td>
<td>@”100” -&gt; 100</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>用例 3</th>
<th>JSON属性是时间字符串，Model属性是NSDate</th>
</tr>
</thead>
<tbody>
<tr>
<td>MJExtension</td>
<td>nil，属性类型与值类型不匹配</td>
</tr>
<tr>
<td>YYModel</td>
<td>支持<a href="https://baike.baidu.com/item/ISO%208601/3910715" target="_blank" rel="noopener">ISO标准时间格式</a>的时间字符串自动转成NSDate</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>用例 4</th>
<th>JSON属性是字符串，Model属性是NSValue</th>
</tr>
</thead>
<tbody>
<tr>
<td>MJExtension</td>
<td>nil，属性类型与值类型不匹配</td>
</tr>
<tr>
<td>YYModel</td>
<td>nil，属性类型与值类型不匹配</td>
</tr>
</tbody>
</table>
<p><code>YYModel</code> 和 <code>MJExtension</code> 都会都属性类型与值类型进行类型检测，避免属性被赋予了错误的类型值，以避免潜在的风险。</p>
<blockquote>
<p>这里需要提一下，ibireme发布的<a href="https://github.com/ibireme/YYModel/tree/master/Benchmark" target="_blank" rel="noopener">转换库评测代码</a>发布于2015-09-18。当时<code>MJExtension</code>的最高版本应该是<a href="https://github.com/CoderMJLee/MJExtension/releases/tag/2.5.7" target="_blank" rel="noopener"><code>2.5.7版本</code></a>，此时的代码中还未添加类型检测的代码。</p>
</blockquote>
<p>对于NSDate类型的JSON数据，如果时间格式满足ISO标准，<code>YYModel</code>支持将ISO标准时间格式的字符串，转换成NSDate类型的值；而<code>MJExtension</code>会因为类型检测不匹配，为模型赋空值（nil）。</p>
<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><table>
<thead>
<tr>
<th>功能</th>
<th style="text-align:center">MJExtension</th>
<th style="text-align:center">YYModel</th>
</tr>
</thead>
<tbody>
<tr>
<td>属性名转换</td>
<td style="text-align:center">✅</td>
<td style="text-align:center">✅</td>
</tr>
<tr>
<td>自定义属性值转换</td>
<td style="text-align:center">✅</td>
<td style="text-align:center">✅</td>
</tr>
<tr>
<td>黑白名单</td>
<td style="text-align:center">✅</td>
<td style="text-align:center">✅</td>
</tr>
<tr>
<td>Coding</td>
<td style="text-align:center">✅</td>
<td style="text-align:center">✅</td>
</tr>
<tr>
<td>Copying</td>
<td style="text-align:center">-</td>
<td style="text-align:center">✅</td>
</tr>
<tr>
<td>hash/equal</td>
<td style="text-align:center">-</td>
<td style="text-align:center">✅</td>
</tr>
<tr>
<td>CoreData</td>
<td style="text-align:center">✅</td>
<td style="text-align:center">-</td>
</tr>
</tbody>
</table>
<h3 id="侵入性"><a href="#侵入性" class="headerlink" title="侵入性"></a>侵入性</h3><p><code>YYModel</code>、<code>MJExtension</code>都采用Category来实现，无侵入，并在方法名之前添加了前缀，与原生方法进行区分。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p><code>YYModel</code>、<code>MJExtension</code>从逻辑上来说是相似的，都通过Category无侵入性地实现功能，且都是使用runtime动态地获取、创建和缓存类元、属性元信息，再通过对数据的遍历进行转换。具体功能上都支持自定义属性名映射和自定义属性值转换，以及方便的归档接档的方法。少部分功能，略有差异，可根据需求选取。<br>从方法/函数使用上来说，<code>MJExtension</code>使用的是Foundation框架的方法，而<code>YYModel</code>使用的是相比之下更底层的CoreFoundation框架的函数，再配合使用内联和纯C函数，能够做到比<code>MJExtension</code>更少的资源开销，从而在性能上有显著的优势。</p>

      
      <!-- 打赏 -->
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/09/14/iOS源码阅读 —— YYModel  vs  MJExtension/" data-id="ckgx5nsfv001t0gbuk2h758aa"
        class="article-share-link">分享</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MJExtension/">MJExtension</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/YYModel/">YYModel</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码阅读/">源码阅读</a></li></ul>

    </footer>

  </div>

  

  

  

</article>
    
    <article id="post-iOS源码阅读 —— MJExtension" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/09/09/iOS源码阅读 —— MJExtension/"
    >iOS源码阅读 —— MJExtension</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/09/09/iOS源码阅读 —— MJExtension/" class="article-date">
  <time datetime="2020-09-09T12:28:59.000Z" itemprop="datePublished">2020-09-09</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

      
      
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>MJExtension是一款开源的，简单易用的字典与模型转换框架。<br>常用的方法，主要是以下几个：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// JSON|字典 转 模型</span><br><span class="line">+ (instancetype)mj_objectWithKeyValues:(id)keyValues;</span><br><span class="line"></span><br><span class="line">// 通过 JSON|字典 为 模型赋值</span><br><span class="line">- (instancetype)mj_setKeyValues:(id)keyValues;</span><br><span class="line"></span><br><span class="line">// 模型转JSON</span><br><span class="line">- (NSMutableDictionary *)mj_keyValues;</span><br><span class="line"></span><br><span class="line">// JSON数组转模型数组</span><br><span class="line">+ (NSMutableArray *)mj_objectArrayWithKeyValuesArray:(id)keyValuesArray;</span><br></pre></td></tr></table></figure></p>
<h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><h2 id="JSON-字典-转-模型"><a href="#JSON-字典-转-模型" class="headerlink" title="JSON|字典 转 模型"></a>JSON|字典 转 模型</h2><h3 id="mj-objectWithKeyValues"><a href="#mj-objectWithKeyValues" class="headerlink" title="+ mj_objectWithKeyValues:"></a>+ mj_objectWithKeyValues:</h3><p><code>+ mj_objectWithKeyValues:</code> 是框架中最简单的JSON转模型的方法，通过直接调用类方法并传入JSON数据即可快速实现转换。而在<code>+ mj_objectWithKeyValues:</code>方法中，实际是调用了<code>+ mj_objectWithKeyValues: context:</code>方法，参数中如果传了<code>contenxt</code>，最终会返回CoreData模型；如果不传，返回已赋值的模型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)mj_objectWithKeyValues:(id)keyValues context:(NSManagedObjectContext *)context</span><br><span class="line">&#123;</span><br><span class="line">    // 获得JSON对象</span><br><span class="line">    keyValues = [keyValues mj_JSONObject];</span><br><span class="line">    MJExtensionAssertError([keyValues isKindOfClass:[NSDictionary class]], nil, [self class], @&quot;keyValues参数不是一个字典&quot;);</span><br><span class="line"></span><br><span class="line">    // 判断是否传入 &quot;contenxt&quot; 参数</span><br><span class="line">    if ([self isSubclassOfClass:[NSManagedObject class]] &amp;&amp; context) &#123;</span><br><span class="line">        NSString *entityName = [NSStringFromClass(self) componentsSeparatedByString:@&quot;.&quot;].lastObject;</span><br><span class="line">        return [[NSEntityDescription insertNewObjectForEntityForName:entityName inManagedObjectContext:context] mj_setKeyValues:keyValues context:context];</span><br><span class="line">    &#125;</span><br><span class="line">    return [[[self alloc] init] mj_setKeyValues:keyValues];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在为实例赋值的方法中，由于<code>- mj_setKeyValues:</code>实际的实现是调用<code>- mj_setKeyValues: context:</code>。所以我们直接进入<code>- mj_setKeyValues: context:</code>进行分析。</p>
<p>首先，需要将传入的<code>keyValues</code>处理成可用的JSON对象，并获取当前类的类型，以及黑白名单属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 获得JSON对象</span><br><span class="line">keyValues = [keyValues mj_JSONObject];</span><br><span class="line">MJExtensionAssertError([keyValues isKindOfClass:[NSDictionary class]], self, [self class], @&quot;keyValues参数不是一个字典&quot;);</span><br><span class="line"></span><br><span class="line">Class clazz = [self class];</span><br><span class="line">NSArray *allowedPropertyNames = [clazz mj_totalAllowedPropertyNames];</span><br><span class="line">NSArray *ignoredPropertyNames = [clazz mj_totalIgnoredPropertyNames];</span><br></pre></td></tr></table></figure></p>
<p>紧接着，调用类的扩展方法<code>+ mj_enumerateProperties:</code>，获取和遍历类的属性列表，通过block参数进行回调，在回调的代码块中，对每个属性进行注意赋值。</p>
<p><strong>核心代码：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">//通过封装的方法回调一个通过运行时编写的，用于返回属性列表的方法。</span><br><span class="line">[clazz mj_enumerateProperties:^(MJProperty *property, BOOL *stop) &#123;</span><br><span class="line">    @try &#123;</span><br><span class="line">        // 0.检测是否被忽略</span><br><span class="line">        if (allowedPropertyNames.count &amp;&amp; ![allowedPropertyNames containsObject:property.name]) return;</span><br><span class="line">        if ([ignoredPropertyNames containsObject:property.name]) return;</span><br><span class="line"></span><br><span class="line">        // 1.取出属性值</span><br><span class="line">        id value;</span><br><span class="line">        NSArray *propertyKeyses = [property propertyKeysForClass:clazz];</span><br><span class="line">        for (NSArray *propertyKeys in propertyKeyses) &#123;</span><br><span class="line">            value = keyValues;</span><br><span class="line">            for (MJPropertyKey *propertyKey in propertyKeys) &#123;</span><br><span class="line">                value = [propertyKey valueInObject:value];</span><br><span class="line">            &#125;</span><br><span class="line">            if (value) break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 值的过滤</span><br><span class="line">        id newValue = [clazz mj_getNewValueFromObject:self oldValue:value property:property];</span><br><span class="line">        if (newValue != value) &#123; // 有过滤后的新值</span><br><span class="line">            [property setValue:newValue forObject:self];</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 如果没有值，就直接返回</span><br><span class="line">        if (!value || value == [NSNull null]) return;</span><br><span class="line"></span><br><span class="line">        // 2.复杂处理</span><br><span class="line">        MJPropertyType *type = property.type; // 数据类型类</span><br><span class="line">        Class propertyClass = type.typeClass; // 对象类型</span><br><span class="line">        Class objectClass = [property objectClassInArrayForClass:[self class]]; // 数组中的模型类型</span><br><span class="line"></span><br><span class="line">        // 不可变 -&gt; 可变处理</span><br><span class="line">        if (propertyClass == [NSMutableArray class] &amp;&amp; [value isKindOfClass:[NSArray class]]) &#123;</span><br><span class="line">            value = [NSMutableArray arrayWithArray:value];</span><br><span class="line">        &#125; else if (propertyClass == [NSMutableDictionary class] &amp;&amp; [value isKindOfClass:[NSDictionary class]]) &#123;</span><br><span class="line">            value = [NSMutableDictionary dictionaryWithDictionary:value];</span><br><span class="line">        &#125; else if (propertyClass == [NSMutableString class] &amp;&amp; [value isKindOfClass:[NSString class]]) &#123;</span><br><span class="line">            value = [NSMutableString stringWithString:value];</span><br><span class="line">        &#125; else if (propertyClass == [NSMutableData class] &amp;&amp; [value isKindOfClass:[NSData class]]) &#123;</span><br><span class="line">            value = [NSMutableData dataWithData:value];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!type.isFromFoundation &amp;&amp; propertyClass) &#123; // 模型属性</span><br><span class="line">            // 既不是基础类型，也不是NS类型。即：基本数据类型</span><br><span class="line">            value = [propertyClass mj_objectWithKeyValues:value context:context];</span><br><span class="line">        &#125; else if (objectClass) &#123;</span><br><span class="line">            if (objectClass == [NSURL class] &amp;&amp; [value isKindOfClass:[NSArray class]]) &#123;</span><br><span class="line">                // string array -&gt; url array</span><br><span class="line">                NSMutableArray *urlArray = [NSMutableArray array];</span><br><span class="line">                for (NSString *string in value) &#123;</span><br><span class="line">                    if (![string isKindOfClass:[NSString class]]) continue;</span><br><span class="line">                    [urlArray addObject:string.mj_url];</span><br><span class="line">                &#125;</span><br><span class="line">                value = urlArray;</span><br><span class="line">            &#125; else &#123; // 字典数组--&gt;模型数组</span><br><span class="line">                value = [objectClass mj_objectArrayWithKeyValuesArray:value context:context];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (propertyClass == [NSString class]) &#123;</span><br><span class="line">            if ([value isKindOfClass:[NSNumber class]]) &#123;</span><br><span class="line">                // NSNumber -&gt; NSString</span><br><span class="line">                value = [value description];</span><br><span class="line">            &#125; else if ([value isKindOfClass:[NSURL class]]) &#123;</span><br><span class="line">                // NSURL -&gt; NSString</span><br><span class="line">                value = [value absoluteString];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if ([value isKindOfClass:[NSString class]]) &#123;</span><br><span class="line">            if (propertyClass == [NSURL class]) &#123;</span><br><span class="line">                // NSString -&gt; NSURL</span><br><span class="line">                // 字符串转码</span><br><span class="line">                value = [value mj_url];</span><br><span class="line">            &#125; else if (type.isNumberType) &#123;</span><br><span class="line">                NSString *oldValue = value;</span><br><span class="line"></span><br><span class="line">                // NSString -&gt; NSDecimalNumber, 使用 DecimalNumber 来转换数字, 避免丢失精度以及溢出</span><br><span class="line">                NSDecimalNumber *decimalValue = [NSDecimalNumber decimalNumberWithString:oldValue</span><br><span class="line">                                                                                  locale:numberLocale];</span><br><span class="line"></span><br><span class="line">                // 检查特殊情况</span><br><span class="line">                if (decimalValue == NSDecimalNumber.notANumber) &#123;</span><br><span class="line">                    value = @(0);</span><br><span class="line">                &#125;else if (propertyClass != [NSDecimalNumber class]) &#123;</span><br><span class="line">                    value = [decimalValue mj_standardValueWithTypeCode:type.code];</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    value = decimalValue;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // 如果是BOOL</span><br><span class="line">                if (type.isBoolType) &#123;</span><br><span class="line">                    // 字符串转BOOL（字符串没有charValue方法）</span><br><span class="line">                    // 系统会调用字符串的charValue转为BOOL类型</span><br><span class="line">                    NSString *lower = [oldValue lowercaseString];</span><br><span class="line">                    if ([lower isEqualToString:@&quot;yes&quot;] || [lower isEqualToString:@&quot;true&quot;]) &#123;</span><br><span class="line">                        value = @YES;</span><br><span class="line">                    &#125; else if ([lower isEqualToString:@&quot;no&quot;] || [lower isEqualToString:@&quot;false&quot;]) &#123;</span><br><span class="line">                        value = @NO;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if ([value isKindOfClass:[NSNumber class]] &amp;&amp; propertyClass == [NSDecimalNumber class])&#123;</span><br><span class="line">            // 过滤 NSDecimalNumber类型</span><br><span class="line">            if (![value isKindOfClass:[NSDecimalNumber class]]) &#123;</span><br><span class="line">                value = [NSDecimalNumber decimalNumberWithDecimal:[((NSNumber *)value) decimalValue]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 经过转换后, 最终检查 value 与 property 是否匹配</span><br><span class="line">        if (propertyClass &amp;&amp; ![value isKindOfClass:propertyClass]) &#123;</span><br><span class="line">            value = nil;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 3.赋值（KVC）</span><br><span class="line">        [property setValue:value forObject:self];</span><br><span class="line">    &#125; @catch (NSException *exception) &#123;</span><br><span class="line">        MJExtensionBuildError([self class], exception.reason);</span><br><span class="line">        MJExtensionLog(@&quot;%@&quot;, exception);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p>
<p>从代码中，可以直观看出，赋值操作主要分为步骤4个步骤。</p>
<h4 id="0-检测是否被忽略"><a href="#0-检测是否被忽略" class="headerlink" title="0.检测是否被忽略"></a>0.检测是否被忽略</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 白名单</span><br><span class="line">if (allowedPropertyNames.count &amp;&amp; ![allowedPropertyNames containsObject:property.name]) return;</span><br><span class="line">// 黑名单</span><br><span class="line">if ([ignoredPropertyNames containsObject:property.name]) return;</span><br></pre></td></tr></table></figure>
<p>判断黑白名单中是否包含相应的属性名称。</p>
<h4 id="1-取出属性值"><a href="#1-取出属性值" class="headerlink" title="1.取出属性值"></a>1.取出属性值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">id value;</span><br><span class="line">NSArray *propertyKeyses = [property propertyKeysForClass:clazz];</span><br><span class="line">for (NSArray *propertyKeys in propertyKeyses) &#123;</span><br><span class="line">    value = keyValues;</span><br><span class="line">    for (MJPropertyKey *propertyKey in propertyKeys) &#123;</span><br><span class="line">        value = [propertyKey valueInObject:value];</span><br><span class="line">    &#125;</span><br><span class="line">    if (value) break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 值的过滤</span><br><span class="line">id newValue = [clazz mj_getNewValueFromObject:self oldValue:value property:property];</span><br><span class="line">if (newValue != value) &#123; // 有过滤后的新值</span><br><span class="line">    [property setValue:newValue forObject:self];</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 如果没有值，就直接返回</span><br><span class="line">if (!value || value == [NSNull null]) return;</span><br></pre></td></tr></table></figure>
<p>因为同一个成员属性，父类和子类的行为可能不一致（originKey、propertyKeys、objectClassInArray），所以其键值可能是一个数组，通过循环这个数组尝试获取值。<br>对值得过滤，指的是使用者通过实现<code>- (id)mj_newValueFromOldValue: property:</code>方法，对结果进行进一步的处理（比如字符串日期处理为NSDate、字符串nil处理为@””）。</p>
<h4 id="2-复杂处理"><a href="#2-复杂处理" class="headerlink" title="2.复杂处理"></a>2.复杂处理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">MJPropertyType *type = property.type; // 数据类型的信息</span><br><span class="line">Class propertyClass = type.typeClass; // 属性的类型</span><br><span class="line">Class objectClass = [property objectClassInArrayForClass:[self class]]; // 数组中模型的类型</span><br><span class="line"></span><br><span class="line">// 不可变 -&gt; 可变处理</span><br><span class="line">if (propertyClass == [NSMutableArray class] &amp;&amp; [value isKindOfClass:[NSArray class]]) &#123;</span><br><span class="line">    value = [NSMutableArray arrayWithArray:value];</span><br><span class="line">&#125; else if (propertyClass == [NSMutableDictionary class] &amp;&amp; [value isKindOfClass:[NSDictionary class]]) &#123;</span><br><span class="line">    value = [NSMutableDictionary dictionaryWithDictionary:value];</span><br><span class="line">&#125; else if (propertyClass == [NSMutableString class] &amp;&amp; [value isKindOfClass:[NSString class]]) &#123;</span><br><span class="line">    value = [NSMutableString stringWithString:value];</span><br><span class="line">&#125; else if (propertyClass == [NSMutableData class] &amp;&amp; [value isKindOfClass:[NSData class]]) &#123;</span><br><span class="line">    value = [NSMutableData dataWithData:value];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (!type.isFromFoundation &amp;&amp; propertyClass) &#123; // 模型属性</span><br><span class="line">    // 既不是基础类型，也不是NS类型。即：基本数据类型</span><br><span class="line">    value = [propertyClass mj_objectWithKeyValues:value context:context];</span><br><span class="line">&#125; else if (objectClass) &#123;</span><br><span class="line">    if (objectClass == [NSURL class] &amp;&amp; [value isKindOfClass:[NSArray class]]) &#123;</span><br><span class="line">        // string array -&gt; url array</span><br><span class="line">        NSMutableArray *urlArray = [NSMutableArray array];</span><br><span class="line">        for (NSString *string in value) &#123;</span><br><span class="line">            if (![string isKindOfClass:[NSString class]]) continue;</span><br><span class="line">            [urlArray addObject:string.mj_url];</span><br><span class="line">        &#125;</span><br><span class="line">        value = urlArray;</span><br><span class="line">    &#125; else &#123; // 字典数组--&gt;模型数组</span><br><span class="line">        value = [objectClass mj_objectArrayWithKeyValuesArray:value context:context];</span><br><span class="line">    &#125;</span><br><span class="line">&#125; else if (propertyClass == [NSString class]) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125; else if ([value isKindOfClass:[NSString class]]) &#123;</span><br><span class="line"></span><br><span class="line">&#125; else if ([value isKindOfClass:[NSNumber class]] &amp;&amp; propertyClass == [NSDecimalNumber class])&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂处理，主要是对属性值的类型进行判断，属性值的类型只要分为：模型属性（自定义类）、数组属性和其他属性（NS类型）。<br>模型属性的value，需要通过继续调用<code>- mj_objectWithKeyValues:value context:</code>方法，将字典转换成模型。<br>数组属性的值，则需要根据数组中模型的类型，进行循环转换。<br>其他情况的值，可以通过简单的转化或者直接使用。</p>
<h4 id="3-赋值"><a href="#3-赋值" class="headerlink" title="3.赋值"></a>3.赋值</h4><p>至此，属性信息和值都有了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 经过转换后, 最终检查 value 与 property 是否匹配</span><br><span class="line">if (propertyClass &amp;&amp; ![value isKindOfClass:propertyClass]) &#123;</span><br><span class="line">    value = nil;</span><br><span class="line">&#125;</span><br><span class="line">[property setValue:value forObject:self];</span><br></pre></td></tr></table></figure></p>
<p>在确定 value的值 与 property得类型 确实匹配后，通过KVC进行赋值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  设置成员变量的值</span><br><span class="line"> */</span><br><span class="line">- (void)setValue:(id)value forObject:(id)object</span><br><span class="line">&#123;</span><br><span class="line">    if (self.type.KVCDisabled || value == nil) return;</span><br><span class="line">    [object setValue:value forKey:self.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>到此，JSON转模型的工作就完成了。</p>
<h2 id="模型-转-JSON-字典"><a href="#模型-转-JSON-字典" class="headerlink" title="模型 转 JSON|字典"></a>模型 转 JSON|字典</h2><h3 id="mj-keyValues"><a href="#mj-keyValues" class="headerlink" title="- mj_keyValues"></a>- mj_keyValues</h3><p>模型转JSON的方法主要有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 转换并返回模型中所有属性的键值对</span><br><span class="line">- (NSMutableDictionary *)mj_keyValues;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> @para keys 需要返回的特定键的数组</span><br><span class="line"> @return 特定关键词的键值对</span><br><span class="line"> */</span><br><span class="line">- (NSMutableDictionary *)mj_keyValuesWithKeys:(NSArray *)keys;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> @para ignoredKeys 需要忽略的特定键的数组</span><br><span class="line"> @return 除特定关键词的其他有效键值对</span><br><span class="line"> */</span><br><span class="line">- (NSMutableDictionary *)mj_keyValuesWithIgnoredKeys:(NSArray *)ignoredKeys;</span><br></pre></td></tr></table></figure></p>
<p>以上方法统一调用了<code>- mj_keyValuesWithKeys:ignoredKeys:</code>，让我们直接进入这个方法一探究竟。<br><code>- mj_keyValuesWithKeys:ignoredKeys:</code>方法与JSON转模型的核心逻辑是极其相似的，即通过遍历类的所有属性，进行相关操作，这里我们直接进入代码块，进行分析。</p>
<h4 id="0-检测是否被忽略-1"><a href="#0-检测是否被忽略-1" class="headerlink" title="0.检测是否被忽略"></a>0.检测是否被忽略</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 白名单</span><br><span class="line">if (allowedPropertyNames.count &amp;&amp; ![allowedPropertyNames containsObject:property.name]) return;</span><br><span class="line">// 黑名单</span><br><span class="line">if ([ignoredPropertyNames containsObject:property.name]) return;</span><br><span class="line">// 只需要返回的特定键</span><br><span class="line">if (keys.count &amp;&amp; ![keys containsObject:property.name]) return;</span><br><span class="line">// 需要被忽略的特定键</span><br><span class="line">if ([ignoredKeys containsObject:property.name]) return;</span><br></pre></td></tr></table></figure>
<p>返回的结果，不仅可以对黑白名单中的属性进行筛选，还可以根据具体场景设置需要返回和忽略的特定键值。</p>
<h4 id="1-取出属性值-1"><a href="#1-取出属性值-1" class="headerlink" title="1.取出属性值"></a>1.取出属性值</h4><p>使用KVC取值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">id value = [property valueForObject:self];</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  获得成员变量的值</span><br><span class="line"> */</span><br><span class="line">- (id)valueForObject:(id)object</span><br><span class="line">&#123;</span><br><span class="line">    if (self.type.KVCDisabled) return [NSNull null];</span><br><span class="line"></span><br><span class="line">    id value = [object valueForKey:self.name];</span><br><span class="line"></span><br><span class="line">    // 32位BOOL类型转换json后成Int类型</span><br><span class="line">    /** https://github.com/CoderMJLee/MJExtension/issues/545 */</span><br><span class="line">    // 32 bit device OR 32 bit Simulator</span><br><span class="line">#if defined(__arm__) || (TARGET_OS_SIMULATOR &amp;&amp; !__LP64__)</span><br><span class="line">    if (self.type.isBoolType) &#123;</span><br><span class="line">        value = @([(NSNumber *)value boolValue]);</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="2-模型属性和数组的处理"><a href="#2-模型属性和数组的处理" class="headerlink" title="2.模型属性和数组的处理"></a>2.模型属性和数组的处理</h4><p>如果当前的属性属于模型类型或数组，则需要对 <code>value</code> 进行递归调用 <code>- mj_keyValues</code> 方法，直至最终得到非模型和非数组的数据类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MJPropertyType *type = property.type;</span><br><span class="line">Class propertyClass = type.typeClass;</span><br><span class="line">if (!type.isFromFoundation &amp;&amp; propertyClass) &#123;</span><br><span class="line">    value = [value mj_keyValues];</span><br><span class="line">&#125; else if ([value isKindOfClass:[NSArray class]]) &#123;</span><br><span class="line">    // 3.处理数组里面有模型的情况</span><br><span class="line">    value = [NSObject mj_keyValuesArrayWithObjectArray:value];</span><br><span class="line">&#125; else if (propertyClass == [NSURL class]) &#123;</span><br><span class="line">    value = [value absoluteString];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="3-赋值-1"><a href="#3-赋值-1" class="headerlink" title="3.赋值"></a>3.赋值</h4><p>在对结果<code>keyValues</code>进行赋值之前，需要先判断创建键值时，是否引用了替换键 —— 也就是在<code>+ mj_replacedKeyFromPropertyName</code>方法中返回的自定义映射表。<br>对于没有引用替换键的值，可以直接赋值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keyValues[property.name] = value;</span><br></pre></td></tr></table></figure></p>
<p>对于引用了替换键的值，需要获取原始的key，最终结果也将返回最原始的JSON或字典。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// 获取原始key</span><br><span class="line">NSArray *propertyKeys = [[property propertyKeysForClass:clazz] firstObject];</span><br><span class="line">NSUInteger keyCount = propertyKeys.count;</span><br><span class="line">// 创建字典</span><br><span class="line">__block id innerContainer = keyValues;</span><br><span class="line">[propertyKeys enumerateObjectsUsingBlock:^(MJPropertyKey *propertyKey, NSUInteger idx, BOOL *stop) &#123;</span><br><span class="line">    // 下一个属性</span><br><span class="line">    MJPropertyKey *nextPropertyKey = nil;</span><br><span class="line">    if (idx != keyCount - 1) &#123;</span><br><span class="line">        nextPropertyKey = propertyKeys[idx + 1];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (nextPropertyKey) &#123; // 不是最后一个key</span><br><span class="line">        // 当前propertyKey对应的字典或者数组</span><br><span class="line">        id tempInnerContainer = [propertyKey valueInObject:innerContainer];</span><br><span class="line">        if (tempInnerContainer == nil || [tempInnerContainer isKindOfClass:[NSNull class]]) &#123;</span><br><span class="line">            if (nextPropertyKey.type == MJPropertyKeyTypeDictionary) &#123;</span><br><span class="line">                tempInnerContainer = [NSMutableDictionary dictionary];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                tempInnerContainer = [NSMutableArray array];</span><br><span class="line">            &#125;</span><br><span class="line">            if (propertyKey.type == MJPropertyKeyTypeDictionary) &#123;</span><br><span class="line">                innerContainer[propertyKey.name] = tempInnerContainer;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                innerContainer[propertyKey.name.intValue] = tempInnerContainer;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if ([tempInnerContainer isKindOfClass:[NSMutableArray class]]) &#123;</span><br><span class="line">            NSMutableArray *tempInnerContainerArray = tempInnerContainer;</span><br><span class="line">            int index = nextPropertyKey.name.intValue;</span><br><span class="line">            while (tempInnerContainerArray.count &lt; index + 1) &#123;</span><br><span class="line">                [tempInnerContainerArray addObject:[NSNull null]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        innerContainer = tempInnerContainer;</span><br><span class="line">    &#125; else &#123; // 最后一个key</span><br><span class="line">        if (propertyKey.type == MJPropertyKeyTypeDictionary) &#123;</span><br><span class="line">            innerContainer[propertyKey.name] = value;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            innerContainer[propertyKey.name.intValue] = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>核心代码：</strong></p>
<ul>
<li>JSON|字典转模型的各类方法，最终都会调用<code>- mj_setKeyValues:(id)keyValues context:</code></li>
<li>模型转JSON|字典的各类方法，最终都会调用<code>- (NSMutableDictionary *)mj_keyValuesWithKeys: ignoredKeys:</code></li>
</ul>
<p><strong>性能方面:</strong></p>
<ul>
<li>使用runtime动态生成类的属性信息，并通过缓存机制进行性能提优。</li>
</ul>
<p><strong>容错方面</strong></p>
<ul>
<li>在JSON|字典转模型最后赋值之前，会对值和属性的类型进行一致性的判断。如果不匹配，<code>value</code>会被置为nil，避免潜在的Crash风险。</li>
</ul>

      
      <!-- 打赏 -->
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/09/09/iOS源码阅读 —— MJExtension/" data-id="ckgx5nsfo001c0gbum98fio6y"
        class="article-share-link">分享</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MJExtension/">MJExtension</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码阅读/">源码阅读</a></li></ul>

    </footer>

  </div>

  

  

  

</article>
    
    <article id="post-iOS源码阅读——YYModel" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/09/03/iOS源码阅读——YYModel/"
    >iOS源码阅读——YYModel</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/09/03/iOS源码阅读——YYModel/" class="article-date">
  <time datetime="2020-09-03T15:14:23.000Z" itemprop="datePublished">2020-09-03</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

      
      
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>YYModel作为一个 iOS/OSX 模型转换框架，为JSON与数据模型之间的转换，提供了高性能的解决方案。</p>
<p>在我个人的日常开发中，主要使用的方法有以下几个：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// JSON|字典 转 模型</span><br><span class="line">+ (nullable instancetype)yy_modelWithJSON:(id)json;</span><br><span class="line">+ (nullable instancetype)yy_modelWithDictionary:(NSDictionary *)dictionary;</span><br><span class="line"></span><br><span class="line">// 通过 JSON|字典 为 模型赋值</span><br><span class="line">- (BOOL)yy_modelSetWithJSON:(id)json;</span><br><span class="line">- (BOOL)yy_modelSetWithDictionary:(NSDictionary *)dic;</span><br><span class="line"></span><br><span class="line">// 模型转JSON</span><br><span class="line">- (NSString *)yy_modelToJSONString;</span><br><span class="line"></span><br><span class="line">// JSON数组转模型数组</span><br><span class="line">+ (nullable NSArray *)yy_modelArrayWithClass:(Class)cls json:(id)json;</span><br></pre></td></tr></table></figure></p>
<p>由于多个功能，最终调用的方法是相同的，所以这里仅列出主要方法的代码解析。</p>
<h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><h2 id="JSON转模型"><a href="#JSON转模型" class="headerlink" title="JSON转模型"></a>JSON转模型</h2><h3 id="yy-modelWithDictionary"><a href="#yy-modelWithDictionary" class="headerlink" title="+ yy_modelWithDictionary:"></a>+ yy_modelWithDictionary:</h3><p>由于调用<code>+ yy_modelWithJSON:</code>方法时，方法内部先将JSON序列化为可用的字典，然后调用<code>+ yy_modelWithDictionary:</code>方法。所以我们直接进入<code>+ yy_modelWithDictionary:</code>进行分析。</p>
<p><strong>代码：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> 通过一组 键-值对(NSDictionary)，创建和返回一个新的实例</span><br><span class="line"> 此方法是线程安全的。</span><br><span class="line"></span><br><span class="line"> @参数： dictionary  一组能够映射实例属性的 键-值对(dictionary)</span><br><span class="line"> 无效的键值对将会被忽略。</span><br><span class="line"></span><br><span class="line"> @返回： 一个通过 键-值对(dictionary) 创建的新实例，出错的情况下返回nil。</span><br><span class="line"></span><br><span class="line"> @说明： 字典中的 key 和 value 将分别映射在模型的属性名，和属性值上。</span><br><span class="line"> 如果值得类型不发与属性相匹配，此方法将尝试根据如下规则，进行转化：</span><br><span class="line"></span><br><span class="line">     `NSString` or `NSNumber` -&gt; c number, such as BOOL, int, long, float, NSUInteger...</span><br><span class="line">     `NSString` -&gt; NSDate, parsed with format &quot;yyyy-MM-dd&apos;T&apos;HH:mm:ssZ&quot;, &quot;yyyy-MM-dd HH:mm:ss&quot; or &quot;yyyy-MM-dd&quot;.</span><br><span class="line">     `NSString` -&gt; NSURL.</span><br><span class="line">     `NSValue` -&gt; struct or union, such as CGRect, CGSize, ...</span><br><span class="line">     `NSString` -&gt; SEL, Class.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">+ (instancetype)yy_modelWithDictionary:(NSDictionary *)dictionary &#123;</span><br><span class="line">    if (!dictionary || dictionary == (id)kCFNull) return nil;</span><br><span class="line">    if (![dictionary isKindOfClass:[NSDictionary class]]) return nil;</span><br><span class="line"></span><br><span class="line">    // 创建当前类的类对象实例</span><br><span class="line">    Class cls = [self class];</span><br><span class="line">    // 创建和获取 模型的元类（包含类的详细信息）</span><br><span class="line">    _YYModelMeta *modelMeta = [_YYModelMeta metaWithClass:cls];</span><br><span class="line"></span><br><span class="line">    // 判断使用者是否自定义 类的（子类）类型</span><br><span class="line">    if (modelMeta-&gt;_hasCustomClassFromDictionary) &#123;</span><br><span class="line">        cls = [cls modelCustomClassForDictionary:dictionary] ?: cls;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 创建实例实例</span><br><span class="line">    NSObject *one = [cls new];</span><br><span class="line"></span><br><span class="line">    // 为属性赋值</span><br><span class="line">    if ([one yy_modelSetWithDictionary:dictionary]) return one;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>+ yy_modelWithDictionary:</code>方法中，主要做了三件事：1.确定类型；2.创建实例；3.为实例赋值。</p>
<h4 id="1-确定类型"><a href="#1-确定类型" class="headerlink" title="1. 确定类型"></a>1. 确定类型</h4><p>在类方法中使用<code>[self class]</code>可以轻松获取当前类的类对象，在这里作者通过类对象创建了该类的类元<code>_YYModelMeta *model</code>，类元中包含了丰富的关于该类的信息。</p>
<p><strong><code>_YYModelMeta</code> 类元的定义：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/// 模型对象的类元信息</span><br><span class="line">@interface _YYModelMeta : NSObject &#123;</span><br><span class="line">    @package</span><br><span class="line">    YYClassInfo *_classInfo;</span><br><span class="line">    /// Key:mapped key and key path, Value:_YYModelPropertyMeta.  数据结构：&#123;&quot;pic&quot;: [_YYModelPropertyMeta new]&#125;</span><br><span class="line">    NSDictionary *_mapper;</span><br><span class="line">    /// Array&lt;_YYModelPropertyMeta&gt;, 所有有效属性元的数组</span><br><span class="line">    NSArray *_allPropertyMetas;</span><br><span class="line">    /// Array&lt;_YYModelPropertyMeta&gt;, 映射到键值路径的属性元</span><br><span class="line">    NSArray *_keyPathPropertyMetas;</span><br><span class="line">    /// Array&lt;_YYModelPropertyMeta&gt;, 映射到多个键的属性元</span><br><span class="line">    NSArray *_multiKeysPropertyMetas;</span><br><span class="line">    /// 有效的键值对数量，所谓有效即包含 _getter、_setter、成员变量。 值与 _mapper.count 相同</span><br><span class="line">    NSUInteger _keyMappedCount;</span><br><span class="line">    /// 数据类型</span><br><span class="line">    YYEncodingNSType _nsType;</span><br><span class="line"></span><br><span class="line">    BOOL _hasCustomWillTransformFromDictionary;</span><br><span class="line">    BOOL _hasCustomTransformFromDictionary;</span><br><span class="line">    BOOL _hasCustomTransformToDictionary;</span><br><span class="line">    BOOL _hasCustomClassFromDictionary;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p>在确定类型之前，需要先判断使用者是否根据不同情况自定义了返回类的（子类）类型，即是否实现了<code>+ modelCustomClassForDictionary:(NSDictionary *)dictionary;</code>方法返回自定义类型。</p>
<p><strong>官方示例：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@class YYCircle, YYRectangle, YYLine;</span><br><span class="line"></span><br><span class="line">@implementation YYShape</span><br><span class="line"></span><br><span class="line">+ (Class)modelCustomClassForDictionary:(NSDictionary*)dictionary &#123;</span><br><span class="line">    if (dictionary[@&quot;radius&quot;] != nil) &#123;</span><br><span class="line">        return [YYCircle class];</span><br><span class="line">    &#125; else if (dictionary[@&quot;width&quot;] != nil) &#123;</span><br><span class="line">        return [YYRectangle class];</span><br><span class="line">    &#125; else if (dictionary[@&quot;y2&quot;] != nil) &#123;</span><br><span class="line">        return [YYLine class];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return [self class];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<h4 id="2-创建实例"><a href="#2-创建实例" class="headerlink" title="2. 创建实例"></a>2. 创建实例</h4><p>确定数据类型后，通过类对象快速创建实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSObject *one = [cls new];</span><br></pre></td></tr></table></figure></p>
<h4 id="3-为实例赋值"><a href="#3-为实例赋值" class="headerlink" title="3. 为实例赋值"></a>3. 为实例赋值</h4><p>调用 <code>-yy_modelSetWithDictionary:</code> 方法为实例赋值。</p>
<p><strong>代码：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)yy_modelSetWithDictionary:(NSDictionary *)dic &#123;</span><br><span class="line">    if (!dic || dic == (id)kCFNull) return NO;</span><br><span class="line">    if (![dic isKindOfClass:[NSDictionary class]]) return NO;</span><br><span class="line"></span><br><span class="line">    // 创建和获取 模型的元类（包含类的详细信息）</span><br><span class="line">    _YYModelMeta *modelMeta = [_YYModelMeta metaWithClass:object_getClass(self)];</span><br><span class="line"></span><br><span class="line">    // 判断当前类的有效属性数量</span><br><span class="line">    if (modelMeta-&gt;_keyMappedCount == 0) return NO;</span><br><span class="line"></span><br><span class="line">    // 判断使用者是否自定义了转换映射</span><br><span class="line">    if (modelMeta-&gt;_hasCustomWillTransformFromDictionary) &#123;</span><br><span class="line">        dic = [((id&lt;YYModel&gt;)self) modelCustomWillTransformFromDictionary:dic];</span><br><span class="line">        if (![dic isKindOfClass:[NSDictionary class]]) return NO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 创建 模型设置上下文</span><br><span class="line">    ModelSetContext context = &#123;0&#125;;</span><br><span class="line">    context.modelMeta = (__bridge void *)(modelMeta);</span><br><span class="line">    context.model = (__bridge void *)(self);</span><br><span class="line">    context.dictionary = (__bridge void *)(dic); //dic or json</span><br><span class="line"></span><br><span class="line">    //  比较 元模型的键值数量 &amp; 传入字典的键值数量</span><br><span class="line">    if (modelMeta-&gt;_keyMappedCount &gt;= CFDictionaryGetCount((CFDictionaryRef)dic)) &#123;</span><br><span class="line">        /**</span><br><span class="line">         @function CFDictionaryApplyFunction</span><br><span class="line">         对字典中的每个键值对调用函数一次。</span><br><span class="line"></span><br><span class="line">         @param  theDict</span><br><span class="line">         要查的字典。</span><br><span class="line"></span><br><span class="line">         @param  applier</span><br><span class="line">         要对字典中的每个值调用一次的回调函数。</span><br><span class="line"></span><br><span class="line">         @param context</span><br><span class="line">         一个指针大小的用户定义值，作为第三个参数传递给applier函数，但此函数不使用它。</span><br><span class="line"></span><br><span class="line">         */</span><br><span class="line">        CFDictionaryApplyFunction((CFDictionaryRef)dic, ModelSetWithDictionaryFunction, &amp;context);</span><br><span class="line"></span><br><span class="line">        if (modelMeta-&gt;_keyPathPropertyMetas) &#123;</span><br><span class="line">            CFArrayApplyFunction((CFArrayRef)modelMeta-&gt;_keyPathPropertyMetas,</span><br><span class="line">                                 CFRangeMake(0, CFArrayGetCount((CFArrayRef)modelMeta-&gt;_keyPathPropertyMetas)),</span><br><span class="line">                                 ModelSetWithPropertyMetaArrayFunction,</span><br><span class="line">                                 &amp;context);</span><br><span class="line">        &#125;</span><br><span class="line">        if (modelMeta-&gt;_multiKeysPropertyMetas) &#123;</span><br><span class="line">            CFArrayApplyFunction((CFArrayRef)modelMeta-&gt;_multiKeysPropertyMetas,</span><br><span class="line">                                 CFRangeMake(0, CFArrayGetCount((CFArrayRef)modelMeta-&gt;_multiKeysPropertyMetas)),</span><br><span class="line">                                 ModelSetWithPropertyMetaArrayFunction,</span><br><span class="line">                                 &amp;context);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        /**</span><br><span class="line">         @function CFArrayApplyFunction</span><br><span class="line">         对数组中的每个元素调用函数一次。</span><br><span class="line"></span><br><span class="line">         @param theArray</span><br><span class="line">         要操作的数组。</span><br><span class="line"></span><br><span class="line">         @param range</span><br><span class="line">         要将函数应用于的数组中的值范围。</span><br><span class="line"></span><br><span class="line">         @param applier</span><br><span class="line">         对数组中给定范围内的每个值调用一次的回调函数。如果此参数不是指向正确原型的函数的指针，则行为未定义。如果在应用程序函数期望的范围内存在或不能正确应用的值，则该行为是未定义的。</span><br><span class="line"></span><br><span class="line">         @param context</span><br><span class="line">         一个指针大小的用户定义值，它作为第二个参数传递给applier函数，但此函数不使用它。如果上下文不是applier函数所期望的内容，则行为是未定义的。</span><br><span class="line"></span><br><span class="line">         */</span><br><span class="line">        CFArrayApplyFunction((CFArrayRef)modelMeta-&gt;_allPropertyMetas,</span><br><span class="line">                             CFRangeMake(0, modelMeta-&gt;_keyMappedCount),</span><br><span class="line">                             ModelSetWithPropertyMetaArrayFunction,</span><br><span class="line">                             &amp;context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (modelMeta-&gt;_hasCustomTransformFromDictionary) &#123;</span><br><span class="line">        return [((id&lt;YYModel&gt;)self) modelCustomTransformFromDictionary:dic];</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里会先判断使用者是否对数据字典做了额外的处理，即是否实现了 <code>-modelCustomWillTransformFromDictionary:</code> 方法。如果有，则返回和使用自定义的字典。</p>
<p>一切准备就绪，创建模型设置上下文<code>ModelSetContext context</code>，准备赋值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    void *modelMeta;  ///&lt; _YYModelMeta 类元</span><br><span class="line">    void *model;      ///&lt; id (self) 实例本身</span><br><span class="line">    void *dictionary; ///&lt; NSDictionary (json) 数据字典（json）</span><br><span class="line">&#125; ModelSetContext;</span><br></pre></td></tr></table></figure></p>
<p>比较 <code>类元的有效键值数量</code> 和 <code>传入字典的键值数量</code>，以较小的代价进行属性的遍历赋值（减少不必要的循环次数）。这里分别使用<code>CFDictionaryApplyFunction( )</code>和<code>CFArrayApplyFunction( )</code> 对应 <code>ModelSetWithDictionaryFunction( )</code>和<code>ModelSetWithPropertyMetaArrayFunction( )</code>，进行遍历调用。二者最终都是通过 <code>ModelSetValueForProperty( )</code> 函数进行赋值的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static void ModelSetValueForProperty(__unsafe_unretained id model,// 实例对象</span><br><span class="line">                                     __unsafe_unretained id value,// 值</span><br><span class="line">                                     __unsafe_unretained _YYModelPropertyMeta *meta //属性元</span><br><span class="line">                                     )</span><br></pre></td></tr></table></figure>
<p><code>ModelSetValueForProperty( )</code> 函数中对属性的数据进行了详细的类型判断，主要分为三大类（C的基础数据类型、Foundation的NS数据类型、自定义数据类型）。除了C的基本数据类型，后者都通过消息发送 <code>objc_msgSend</code> 的方式，调用属性的 <code>meta-&gt;_setter</code> 方法进行赋值。</p>
<p>由于实现代码较长，这里就不展示了，有兴趣的可以自行查看源码：<a href="https://github.com/ibireme/YYModel/blob/master/YYModel/NSObject+YYModel.m" target="_blank" rel="noopener">《YYModel/NSObject+YYModel.m》第784~1098行</a>。</p>
<p>到此，JSON转模型的工作就完成了。</p>
<h2 id="模型转JSON"><a href="#模型转JSON" class="headerlink" title="模型转JSON"></a>模型转JSON</h2><h3 id="yy-modelToJSONString"><a href="#yy-modelToJSONString" class="headerlink" title="+ yy_modelToJSONString:"></a>+ yy_modelToJSONString:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (id)yy_modelToJSONObject &#123;</span><br><span class="line">    /*</span><br><span class="line">     Apple said:</span><br><span class="line">     The top level object is an NSArray or NSDictionary.</span><br><span class="line">     All objects are instances of NSString, NSNumber, NSArray, NSDictionary, or NSNull.</span><br><span class="line">     All dictionary keys are instances of NSString.</span><br><span class="line">     Numbers are not NaN or infinity.</span><br><span class="line">     */</span><br><span class="line">    id jsonObject = ModelToJSONObjectRecursive(self);</span><br><span class="line">    if ([jsonObject isKindOfClass:[NSArray class]]) return jsonObject;</span><br><span class="line">    if ([jsonObject isKindOfClass:[NSDictionary class]]) return jsonObject;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSData *)yy_modelToJSONData &#123;</span><br><span class="line">    id jsonObject = [self yy_modelToJSONObject];</span><br><span class="line">    if (!jsonObject) return nil;</span><br><span class="line">    return [NSJSONSerialization dataWithJSONObject:jsonObject options:0 error:NULL];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)yy_modelToJSONString &#123;</span><br><span class="line">    NSData *jsonData = [self yy_modelToJSONData];</span><br><span class="line">    if (jsonData.length == 0) return nil;</span><br><span class="line">    return [[NSString alloc] initWithData:jsonData encoding:NSUTF8StringEncoding];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从方法实现中不难看出，模型转JSON主要依赖于递归函数 <code>ModelToJSONObjectRecursive</code>，该函数最终将返回一个有效的JSON对象（NSArray/NSDictionary/NSString/NSNumber/NSNull）。</p>
<p><strong><code>ModelToJSONObjectRecursive</code> 内部实现代码拆解：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (!model || model == (id)kCFNull) return model;</span><br><span class="line">if ([model isKindOfClass:[NSString class]]) return model;</span><br><span class="line">if ([model isKindOfClass:[NSNumber class]]) return model;</span><br><span class="line">if ([model isKindOfClass:[NSURL class]]) return ((NSURL *)model).absoluteString;</span><br><span class="line">if ([model isKindOfClass:[NSAttributedString class]]) return ((NSAttributedString *)model).string;</span><br><span class="line">if ([model isKindOfClass:[NSDate class]]) return [YYISODateFormatter( ) stringFromDate:(id)model];</span><br><span class="line">if ([model isKindOfClass:[NSData class]]) return nil;</span><br></pre></td></tr></table></figure></p>
<p>当模型值符合或接近目标类型时，可做简单的转换或直接返回.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">// 字典</span><br><span class="line">if ([model isKindOfClass:[NSDictionary class]]) &#123;</span><br><span class="line">    if ([NSJSONSerialization isValidJSONObject:model]) return model;</span><br><span class="line">    NSMutableDictionary *newDic = [NSMutableDictionary new];</span><br><span class="line">    [((NSDictionary *)model) enumerateKeysAndObjectsUsingBlock:^(NSString *key, id obj, BOOL *stop) &#123;</span><br><span class="line">        NSString *stringKey = [key isKindOfClass:[NSString class]] ? key : key.description;</span><br><span class="line">        if (!stringKey) return;</span><br><span class="line">        id jsonObj = ModelToJSONObjectRecursive(obj);</span><br><span class="line">        if (!jsonObj) jsonObj = (id)kCFNull;</span><br><span class="line">        newDic[stringKey] = jsonObj;</span><br><span class="line">    &#125;];</span><br><span class="line">    return newDic;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 集合</span><br><span class="line">if ([model isKindOfClass:[NSSet class]]) &#123;</span><br><span class="line">    NSArray *array = ((NSSet *)model).allObjects;</span><br><span class="line">    if ([NSJSONSerialization isValidJSONObject:array]) return array;</span><br><span class="line">    NSMutableArray *newArray = [NSMutableArray new];</span><br><span class="line">    for (id obj in array) &#123;</span><br><span class="line">        if ([obj isKindOfClass:[NSString class]] || [obj isKindOfClass:[NSNumber class]]) &#123;</span><br><span class="line">            [newArray addObject:obj];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            id jsonObj = ModelToJSONObjectRecursive(obj);</span><br><span class="line">            if (jsonObj &amp;&amp; jsonObj != (id)kCFNull) [newArray addObject:jsonObj];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return newArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 数组</span><br><span class="line">if ([model isKindOfClass:[NSArray class]]) &#123;</span><br><span class="line">    if ([NSJSONSerialization isValidJSONObject:model]) return model;</span><br><span class="line">    NSMutableArray *newArray = [NSMutableArray new];</span><br><span class="line">    for (id obj in (NSArray *)model) &#123;</span><br><span class="line">        if ([obj isKindOfClass:[NSString class]] || [obj isKindOfClass:[NSNumber class]]) &#123;</span><br><span class="line">            [newArray addObject:obj];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            id jsonObj = ModelToJSONObjectRecursive(obj);</span><br><span class="line">            if (jsonObj &amp;&amp; jsonObj != (id)kCFNull) [newArray addObject:jsonObj];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return newArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当模型值为字典、集合数组类型时，需要遍历和递归其内部元素，直至逐一转化成有效的JSON对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">// 自定义类</span><br><span class="line">_YYModelMeta *modelMeta = [_YYModelMeta metaWithClass:[model class]];</span><br><span class="line">if (!modelMeta || modelMeta-&gt;_keyMappedCount == 0) return nil;</span><br><span class="line">NSMutableDictionary *result = [[NSMutableDictionary alloc] initWithCapacity:64];</span><br><span class="line">__unsafe_unretained NSMutableDictionary *dic = result; // avoid retain and release in block</span><br><span class="line">[modelMeta-&gt;_mapper enumerateKeysAndObjectsUsingBlock:^(NSString *propertyMappedKey, _YYModelPropertyMeta *propertyMeta, BOOL *stop) &#123;</span><br><span class="line">    if (!propertyMeta-&gt;_getter) return;</span><br><span class="line"></span><br><span class="line">    id value = nil;</span><br><span class="line">    if (propertyMeta-&gt;_isCNumber) &#123;</span><br><span class="line">        value = ModelCreateNumberFromProperty(model, propertyMeta);</span><br><span class="line">    &#125; else if (propertyMeta-&gt;_nsType) &#123;</span><br><span class="line">        id v = ((id (*)(id, SEL))(void *) objc_msgSend)((id)model, propertyMeta-&gt;_getter);</span><br><span class="line">        value = ModelToJSONObjectRecursive(v);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        switch (propertyMeta-&gt;_type &amp; YYEncodingTypeMask) &#123;</span><br><span class="line">            case YYEncodingTypeObject: &#123;</span><br><span class="line">                id v = ((id (*)(id, SEL))(void *) objc_msgSend)((id)model, propertyMeta-&gt;_getter);</span><br><span class="line">                value = ModelToJSONObjectRecursive(v);</span><br><span class="line">                if (value == (id)kCFNull) value = nil;</span><br><span class="line">            &#125; break;</span><br><span class="line">            case YYEncodingTypeClass: &#123;</span><br><span class="line">                Class v = ((Class (*)(id, SEL))(void *) objc_msgSend)((id)model, propertyMeta-&gt;_getter);</span><br><span class="line">                value = v ? NSStringFromClass(v) : nil;</span><br><span class="line">            &#125; break;</span><br><span class="line">            case YYEncodingTypeSEL: &#123;</span><br><span class="line">                SEL v = ((SEL (*)(id, SEL))(void *) objc_msgSend)((id)model, propertyMeta-&gt;_getter);</span><br><span class="line">                value = v ? NSStringFromSelector(v) : nil;</span><br><span class="line">            &#125; break;</span><br><span class="line">            default: break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!value) return;</span><br><span class="line"></span><br><span class="line">    if (propertyMeta-&gt;_mappedToKeyPath) &#123;</span><br><span class="line">        NSMutableDictionary *superDic = dic;</span><br><span class="line">        NSMutableDictionary *subDic = nil;</span><br><span class="line">        for (NSUInteger i = 0, max = propertyMeta-&gt;_mappedToKeyPath.count; i &lt; max; i++) &#123;</span><br><span class="line">            NSString *key = propertyMeta-&gt;_mappedToKeyPath[i];</span><br><span class="line">            if (i + 1 == max) &#123; // end</span><br><span class="line">                if (!superDic[key]) superDic[key] = value;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            subDic = superDic[key];</span><br><span class="line">            if (subDic) &#123;</span><br><span class="line">                if ([subDic isKindOfClass:[NSDictionary class]]) &#123;</span><br><span class="line">                    subDic = subDic.mutableCopy;</span><br><span class="line">                    superDic[key] = subDic;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                subDic = [NSMutableDictionary new];</span><br><span class="line">                superDic[key] = subDic;</span><br><span class="line">            &#125;</span><br><span class="line">            superDic = subDic;</span><br><span class="line">            subDic = nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (!dic[propertyMeta-&gt;_mappedToKey]) &#123;</span><br><span class="line">            dic[propertyMeta-&gt;_mappedToKey] = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>当模型值为自定义类型时，需要遍历和递归其映射表<code>_mapper</code>（{属性名: 属性元}），通过消息发送 <code>objc_msgSend</code> 的方式，调用属性的 <code>meta-&gt;_getter</code> 方法进行取值，直至逐一转化成有效的JSON对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (modelMeta-&gt;_hasCustomTransformToDictionary) &#123;</span><br><span class="line">    // 校验数据</span><br><span class="line">    BOOL suc = [((id&lt;YYModel&gt;)model) modelCustomTransformToDictionary:dic];</span><br><span class="line">    if (!suc) return nil;</span><br><span class="line">&#125;</span><br><span class="line">return result;</span><br></pre></td></tr></table></figure>
<p>最后，判断使用者是否有额外的转换处理，并并校验数据的有效性。</p>
<blockquote>
<p>注意：<code>result</code> 和 <code>dic</code> 指向的是同一个实例，所以如果 <code>dic</code> 在外部函数中被修改了，等同于修改了 <code>result</code>。</p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>YYModel的使用无侵入性，采用Category的方式实现功能，比较灵活。</li>
<li>容错方面，YYModel对数据类型做了详细的分类和判断，就算转换失败，也会自动留空（nil）。</li>
<li>性能方面，使用 <code>CoreFoundation</code>、内联函数、runtime、缓存机制等方式，减少不必要的开销。</li>
</ul>

      
      <!-- 打赏 -->
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/09/03/iOS源码阅读——YYModel/" data-id="ckgx5nsfw001w0gbun7498dgr"
        class="article-share-link">分享</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/YYModel/">YYModel</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码阅读/">源码阅读</a></li></ul>

    </footer>

  </div>

  

  

  

</article>
    
    <article id="post-2020年8月读书心得" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/08/31/2020年8月读书心得/"
    >2020年8月读书心得</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/08/31/2020年8月读书心得/" class="article-date">
  <time datetime="2020-08-31T15:15:49.000Z" itemprop="datePublished">2020-08-31</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/阅读/">阅读</a>
  </div>

      
      
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p><img src="https://img.alicdn.com/i1/2453833909/TB2x34gnVXXXXXFXpXXXXXXXXXX_!!2453833909.jpg_q90.jpg" alt=""></p>
<h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>起因是我在小专栏中看到了<a href="https://xiaozhuanlan.com/seestocks" target="_blank" rel="noopener">《美港股投资入门指南》 by 寂小桦</a>，就饶有兴趣的看起来。<br>可能很多人都渴望在股票的牛市里分到一杯羹，我也是其中一个。如果说仅仅是作为一个业余的投资者，恰当的股票投资，也能够为投资者带来可观的被动收入，这便是我对股票开始有兴趣的原因。专栏中还有一篇专门推荐<a href="https://xiaozhuanlan.com/topic/7952486301" target="_blank" rel="noopener">《给股票投资新手的书单》</a>。十分值得参考，《股票大作手回忆录》便是我读完的书单里的第一本书。</p>
<h3 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h3><blockquote>
<p>能看对波动方向的人很多，能看对波动并坚持不动的人才真正厉害。但是，一个股票投资者只有牢牢掌握了这个诀窍才能赚大钱。而这是最难学的。</p>
</blockquote>
<p>这里我就直接拿作者举例了。就算强如利弗摩尔这样的操盘手，在他的投资生涯当中也是几经沉浮，不断地上演破产又东山再起又破产的故事。原因恰恰都是因为他没有坚守自己的投资原则。本书没有太多的干货，但是不乏十分具体的操盘过程和细节，而作者始终想告诉读者的其实是，交易方法任何人都可以学习，而获得什么样的结果，最终取决于对自身的认知和心性。</p>
<blockquote>
<p>投资从无新鲜事。所有的一切都是轮回。</p>
</blockquote>
<p>此话无需多言，你品，你细品。</p>
<h3 id="股市永远是对的"><a href="#股市永远是对的" class="headerlink" title="股市永远是对的"></a>股市永远是对的</h3><blockquote>
<p>真正打败我的，是我没有继续坚持我的交易方法。换句话说，只有当市场上有先例支持我的交易计划时，我才做交易。</p>
</blockquote>
<p>任何投资都不应该仅凭主观意识下决定，而是应该通过市场和行情，甚至在有必要的时候，交上一笔”学费“，以证明当下的判断是对是错。不要因为跌了几个点，就慌乱了阵脚，相信自己的判断才是最重要的。</p>
<h3 id="在正确的时机买进卖出"><a href="#在正确的时机买进卖出" class="headerlink" title="在正确的时机买进卖出"></a>在正确的时机买进卖出</h3><blockquote>
<p>我从不介意告诉别人我对市场的看法，无论是看好还是看坏。但也仅仅于此，我从不会告诉别人是买进还是抛出具体的某种股票。</p>
</blockquote>
<p>作者在文中提到，许多人不会听取他对股市的分析和看法，他们只希望确切地知道到底该买什么，抛什么。”而和市场打交道，就应该默默无闻，一声不吭。否则，只会招来非议和提防。这对投资没有任何好处“</p>
<h3 id="真正的股市之王"><a href="#真正的股市之王" class="headerlink" title="真正的股市之王"></a>真正的股市之王</h3><blockquote>
<p>当投资机会来临时，不要畏首畏尾、裹足不前。如果有利可图，而风险又在可承受的范围内，就应果断地采取行动。—— 索罗斯</p>
</blockquote>
<p></p>

<blockquote>
<p>我一直遵循一条古老的交易原则，那就是当股票第一次上穿100美元、200美元或300美元时，上涨的趋势是不会就此止步的，只会升高更多。因而只要它一上穿关键点你就买，肯定能赚上一笔，胆小的人不喜欢在股价创新高时买入股票，但我却有类似的“史实”来指引我在这个时候大胆买入。</p>
</blockquote>
<p></p>

<blockquote>
<p>对我来说，赚钱的方法就是行动起来，而赚大钱的方法却是要在机会来临的时候做出正确的选择。在这一行业你要理论结合实际，绝不能只做书面研究，而是既要做一个研究者，又要做一个投机者。</p>
</blockquote>
<p>个人感觉，作者的经验，仅适用于作者本人。因为文中其实多次提到，利弗摩尔经常会有要抛出或买进某只股票的预感，值得注意的是，这种预感不是空穴来风的。或许是因为他几十年作手生涯积累的经验和直觉，在潜意识中告诉了他答案。所以作者想告诉我们的是，如果建立起了自己的交易原则，且行情风险又恰好都在能接受的体系之内，就应该相信自己，果断采取行动，抓住赚取利润的机会。</p>
<h3 id="别让希望和恐惧伤害你"><a href="#别让希望和恐惧伤害你" class="headerlink" title="别让希望和恐惧伤害你"></a>别让希望和恐惧伤害你</h3><blockquote>
<p>在所有游戏中，唯一真正需要在行动前做好准备的恰恰是准备本身，有些人在用他一半的财产冒险时，用来准备的时间还没有买一辆平价汽车考虑的时间久。</p>
</blockquote>
<p></p>

<blockquote>
<p>在建仓的过程中，总会先亏掉5万或6万美元去测试市场。看起来这种测试的代价确实不小，但事实并非如此，当真正的行情开始时，这点亏损很快就会赚回来，只有把握住正确的机会才能赚到钱。</p>
</blockquote>
<p></p>

<blockquote>
<p>我对自己的交易方法已经说得很清楚了，只在稳操胜券的时候才下大注，而犯错的时候只亏损一点探测性的赌注，这种做法相当英明。如果按我说的方法去交易，就可以始终持有有利润的头寸，回报也总是最为丰厚。</p>
</blockquote>
<p>大多数情况下，股市并不会像投机者心里一厢情愿所期盼的方向发展，如果心中有了预测方向，接下去要做的就应该是通过少量下注和跟踪来论证自己的假设，检验市场的走势和自己的判断是否一致或者相悖，不管结局是哪一种，按做好计划，按计划执行，大概率地情况下，能够赚取到不错的利润，或者规避掉可能的损失。永远不要去打无准备的战争，不然结局可能会很惨。</p>
<blockquote>
<p>投机商真正的敌人往往是自己内心的想法，它与人性的希望和恐惧融为一体。在交易中，当市场对你不利时，你总是希望这一天早日结束，但你失去的总是比你预想的要多；当市场一旦按你的方向走，你就会心生恐惧，担心第二天你的利润就没有了，于是迅速终结交易。恐惧使你没有勇气赚得即将到手的钱，一个成功的交易商必须要战胜这两种根深蒂固的本能，打消本能的冲动。别人认为充满希望的时候警惕谨慎，而别人徘徊犹豫的时候大胆出手。他必须时刻警惕他的亏损会让自己无力承受，也必须希望他的利润能迅猛增长。平常人对股票所持有的赌博观念是十分错误的。</p>
</blockquote>
<p>每个人都应该有自己的交易原则和止损线，而不应该让贪婪和恐惧侵占了大脑中所有的理智。</p>
<h3 id="交易者无法离开市场"><a href="#交易者无法离开市场" class="headerlink" title="交易者无法离开市场"></a>交易者无法离开市场</h3><blockquote>
<p>对于业余投资者来说，非常重要的一点是要用一种适当怀疑的眼光来审视专业投资人，至少这样做可以让你弄清楚在投资中你所面对的是一些什么样的人。由于主要上市公司70%的股票都掌握在机构投资者手中，因此不论你是买入还是卖出股票的时候，你所面对的投资竞争对手是专业投资者的可能性越来越大。—— 彼得·林奇</p>
</blockquote>
<p>论投机，个人应该是玩儿不过机构投资者，所以个人投资更应该倾向于对上市公司长期的价值投资，而非短期投机。</p>
<h3 id="投机者要接受必要的训练"><a href="#投机者要接受必要的训练" class="headerlink" title="投机者要接受必要的训练"></a>投机者要接受必要的训练</h3><blockquote>
<p>业余投资者只要花少量时间，研究自己比较熟悉的行业中的几家上市公司，股票投资业绩就能超过95%的管理基金的专业投资者，而且会从中得到许多乐趣。—— 彼得·林奇</p>
</blockquote>
<p>即：做认知内的投资。</p>
<h3 id="当心“匿名内幕人”的“忠告”"><a href="#当心“匿名内幕人”的“忠告”" class="headerlink" title="当心“匿名内幕人”的“忠告”"></a>当心“匿名内幕人”的“忠告”</h3><blockquote>
<p>大众必须牢记一点：股价长期下跌绝不是空头打压所致。一只股票不断下跌时，背后一定存在着隐情，不是市场有问题，就是公司本身有问题。</p>
</blockquote>
<p>由于作手的操盘，造成短期内走势出现较大的波动，是有可能的。但从长期来看，股票的价格，体现的是公司的价值所在，这才是投资的本质和初衷。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>作者在书中多处详细地描述了他在期货、股票上的操作，值得多读细品。对于我一个股市小白来说，收货还是很大的。入股市之前，提升专业知识和自我认知尤为重要。操作股票不仅需要技巧，更是考验人性的一件事。</p>

      
      <!-- 打赏 -->
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/31/2020年8月读书心得/" data-id="ckgx5nsf8000e0gbuzpwryxgf"
        class="article-share-link">分享</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/读书心得/">读书心得</a></li></ul>

    </footer>

  </div>

  

  

  

</article>
    
    <article id="post-LPR浮动利率究竟是什么？" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/08/29/LPR浮动利率究竟是什么？/"
    >LPR浮动利率究竟是什么？</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/08/29/LPR浮动利率究竟是什么？/" class="article-date">
  <time datetime="2020-08-29T05:40:19.000Z" itemprop="datePublished">2020-08-29</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/科普/">科普</a>
  </div>

      
      
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h3 id="写作目的"><a href="#写作目的" class="headerlink" title="写作目的"></a>写作目的</h3><p>相信各位可能和我一样，在前段时间收到了一条短信，内容大致为：</p>
<blockquote>
<p>按照人民银行[2019]30号公告要求，为简化您的操作，XX银行将于2020年8月25日起将您在我行的住房贷款转换为LPR浮动利率定价方式。</p>
</blockquote>
<p>此时的我，一脸懵逼，LPR利率是个什么玩儿？它还是浮动的？那岂不是以后的利息都没准儿？利息有可能会升高吗？</p>
<p>在观看了B站李永乐老师的视频<a href="https://www.bilibili.com/video/BV1AJ41157sM" target="_blank" rel="noopener">《房贷合同要变了！LPR利率和固定利率哪个合算？会影响房价走势吗?》</a>之后，对LPR浮动利率和利率转换有了一定的认识，在这里和大家分享一下。</p>
<h3 id="贷款基准利率"><a href="#贷款基准利率" class="headerlink" title="贷款基准利率"></a>贷款基准利率</h3><p>在实行LPR浮动利率之前，我们实行的是贷款基准利率，商业银行的利率计算公式为：</p>
<blockquote>
<p>商业银行贷款利率 = 基准利率 * (1 + 浮动加点)<br>央行基准利率：4.9%（2015公布~至今）<br>浮点：根据央行、政策、银行、个人情况而定</p>
</blockquote>
<p>实例：假设某个城市对首套房的浮动加点是10%，那么我们的贷款利率就是：</p>
<blockquote>
<p>首套贷款利率：4.9% * (1 + 10%) = 5.39%</p>
</blockquote>
<p>数字先放这儿，后面会用到。</p>
<h3 id="利率的双轨制"><a href="#利率的双轨制" class="headerlink" title="利率的双轨制"></a>利率的双轨制</h3><p>原有的贷款利率带来的问题是，<code>市场利率</code>和<code>政策利率</code>存在双轨制。<br>市场利率也就是市场对资金需求程度，决定了利率的变化。市场如果非常需要资金，那么利率就上升；如果市场资金比较充裕，那么利率相对地就会下降。<br>这里涉及到MLF利率的问题，MLF的定义，我们不去管它，大体理解就是，央行给商行投钱，商行需要一些抵押给央行，后期在通过一定利率将钱还给央行，这里就存在一个MLF利率。<br>而政策利率，主要指的就是基准利率。商行拿到钱之后，再加上一定的浮动，贷款给客人或企业。<br>这样会出现一个问题，那就是货币政策传导不畅。<br>当MLF下调，商行拿到了钱。但是基准利率没有及时下调，那么贷款利率还是很高，那么个人和企业还是很难贷到钱。<br>这就是利率双轨制存在的问题。</p>
<h3 id="贷款基础利率"><a href="#贷款基础利率" class="headerlink" title="贷款基础利率"></a>贷款基础利率</h3><p>也就是LPR利率。简单说：</p>
<blockquote>
<p>LPR利率 ＝ MLF利率 + 商行平均加点</p>
</blockquote>
<p>这里的商行平均加点，是怎么得来的呢？<br>它是由国内选出来的18家商业银行，一起来报价决定，这18家银行可能来自大型国有银行，城市银行，外资银行和物联网银行等不同的类型。这些银行有不同的特色，服务于不同的人群，可以综合地从各个方面代表整体的市场情况。由这些银行各自根据市场情况报价，最后去除最高和最低，取平均即可。</p>
<p>在LPR利率下，我们的贷款利率就变为了：</p>
<blockquote>
<p>贷款利率 ＝ LPR利率 + 政策加点 + 商行附加利率<br>LPR利率：4.8%（2019年12月）<br>政策加点：如果国家觉得首套房利率不能下浮，那至少要保持LPR利率，那么政策加点可是是0%；限制二套房的购买，那二套房的政策加点可以定为0.6%<br>商行附加利率：商行需要盈利，所以也会有个加点。假设是0.59%</p>
</blockquote>
<p>那么首套房和二套房的利率就分别为：</p>
<blockquote>
<p>首套：4.8% + 0% + 0.59% = 5.39%<br>二套：4.8% + 0.6% + 0.59% = 5.99%</p>
</blockquote>
<p>以上都是针对新利率执行之后的贷款进行的解释，没有太大问题。而接下来就是我们最关心的问题，还在还款期内的贷款是如何转换的。</p>
<h3 id="基准利率-转-基础理论"><a href="#基准利率-转-基础理论" class="headerlink" title="基准利率 转 基础理论"></a>基准利率 转 基础理论</h3><p>根据国家政策，在转化的第一年的一整年时间里，也就是2020年，它会保证我们的利率是和2019年12月20日是一模一样的。（上文我们假定了我们原先的贷款利率是5.39%）。细心的童鞋一定发现了，原先的贷款利率和LPR利率之间存在一个差值，我们可以称这个差值为<code>加点</code>，因为这是我们后期利率计算的条件之一。</p>
<blockquote>
<p>原有贷款利率 = LPR利率 + 加点(差值)<br>5.39% = 4.8% + <u>0.59%</u><br>注意：原本的利率如果是低于LPR利率的，加点值允许是负的。</p>
</blockquote>
<p>得到了加点的具体指，那么我们以后每年的房贷利率就会根据LPR的调整而改变了。有些人可能会担心，如果LPR上升了，我的贷款利率不就上去了吗？根据世界范围的运行规律，国家发展到一定程度后，利率都是会下降的。长期来看，利率下行的概率应该是高于利率上行的概率的。<br>下面附上一张近一年的利率走势表，供大家参考。</p>
<table>
<thead>
<tr>
<th>日期</th>
<th>1年期LPR利率（%）</th>
<th>5年期LPR利率（%）</th>
</tr>
</thead>
<tbody>
<tr>
<td>2020-08-20</td>
<td>3.85</td>
<td>4.65</td>
</tr>
<tr>
<td>2020-07-20</td>
<td>3.85</td>
<td>4.65</td>
</tr>
<tr>
<td>2020-06-20</td>
<td>3.85</td>
<td>4.65</td>
</tr>
<tr>
<td>2020-05-20</td>
<td>3.85</td>
<td>4.65</td>
</tr>
<tr>
<td>2020-04-20</td>
<td>3.85</td>
<td>4.65</td>
</tr>
<tr>
<td>2020-03-20</td>
<td>4.05</td>
<td>4.75</td>
</tr>
<tr>
<td>2020-02-20</td>
<td>4.05</td>
<td>4.75</td>
</tr>
<tr>
<td>2020-01-20</td>
<td>4.15</td>
<td>4.80</td>
</tr>
<tr>
<td>2019-12-20</td>
<td>4.15</td>
<td>4.80</td>
</tr>
<tr>
<td>2019-11-20</td>
<td>4.15</td>
<td>4.80</td>
</tr>
<tr>
<td>2019-10-20</td>
<td>4.20</td>
<td>4.85</td>
</tr>
<tr>
<td>2019-09-20</td>
<td>4.20</td>
<td>4.85</td>
</tr>
<tr>
<td>2019-08-20</td>
<td>4.25</td>
<td>4.85</td>
</tr>
</tbody>
</table>

      
      <!-- 打赏 -->
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/29/LPR浮动利率究竟是什么？/" data-id="ckgx5nsfj00110gbuu5ut0hoj"
        class="article-share-link">分享</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LPR/">LPR</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/金融/">金融</a></li></ul>

    </footer>

  </div>

  

  

  

</article>
    
    <article id="post-LeetCode算法学习日记（2020年8月）" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/08/28/LeetCode算法学习日记（2020年8月）/"
    >LeetCode算法学习日记（2020年8月）</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/08/28/LeetCode算法学习日记（2020年8月）/" class="article-date">
  <time datetime="2020-08-28T12:04:05.000Z" itemprop="datePublished">2020-08-28</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/算法/">算法</a>
  </div>

      
      
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h3 id="2020-8-14"><a href="#2020-8-14" class="headerlink" title="2020.8.14"></a>2020.8.14</h3><hr>
<p><b>题目：</b>有效的括号<br><b>解题思路：</b>栈<br><b>示例：</b></p>
<blockquote>
<p>输入： “( ) [ ] { }”<br>输出： true</p>
<p>输入： “( [ ) ]”<br>输出： false</p>
</blockquote>
<p><b>代码：</b><br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">isValid</span><span class="params">(<span class="number">_</span> s: String)</span></span> -&gt; <span class="type">Bool</span> &#123;       </span><br><span class="line">    <span class="keyword">if</span> s.isEmpty &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> dic:[<span class="type">Character</span>:<span class="type">Int</span>] = [<span class="string">"("</span>:<span class="number">1</span>,<span class="string">")"</span>:<span class="number">2</span>,<span class="string">"["</span>:<span class="number">3</span>,<span class="string">"]"</span>:<span class="number">4</span>,<span class="string">"&#123;"</span>:<span class="number">5</span>,<span class="string">"&#125;"</span>:<span class="number">6</span>]</span><br><span class="line">    <span class="keyword">var</span> arr = [s[s.startIndex]]</span><br><span class="line">    <span class="keyword">var</span> isSkip = <span class="literal">false</span> <span class="comment">//是否清空</span></span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">1</span>..&lt;s.<span class="built_in">count</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> currentS : <span class="type">Character</span> = s[s.index(s.startIndex, offsetBy: index)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> isSkip &#123;</span><br><span class="line">            isSkip = <span class="literal">false</span></span><br><span class="line">            arr = [currentS]</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> lastS : <span class="type">Character</span>? = arr.last</span><br><span class="line">        <span class="keyword">let</span> currentNum = dic[currentS] <span class="comment">// 当前符号代表的数</span></span><br><span class="line">        <span class="keyword">let</span> lastNum = dic[lastS!] <span class="comment">// 栈顶符号代表的数</span></span><br><span class="line">        <span class="keyword">if</span> (lastNum! == <span class="number">1</span> &amp;&amp; currentNum! == <span class="number">2</span>) || (lastNum! == <span class="number">3</span> &amp;&amp; currentNum! == <span class="number">4</span>) || (lastNum! == <span class="number">5</span> &amp;&amp; currentNum! == <span class="number">6</span>)&#123;</span><br><span class="line">            arr.removeLast()</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            arr.append(currentS)</span><br><span class="line">        &#125;</span><br><span class="line">        isSkip = (arr.<span class="built_in">count</span> == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr.<span class="built_in">count</span> &gt; <span class="number">0</span> ? <span class="literal">false</span> : <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><b>算法理解：</b><br>当我们在遍历的时候，遇到左括号，就希望在后续中有右括号与之对应。根据先出现的左括号，延后对应，后出现的左括号，遇到右括号先对应的特点，栈的特点非常适合这道题的解题思路（先进后出）。<br>我们可以依次将一个符号压入栈顶，当有左括号遇到右括号时，两两相消，一直到最后如果栈内符号全部消除，则说明这组符号是有效的。</p>

      
      <!-- 打赏 -->
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/28/LeetCode算法学习日记（2020年8月）/" data-id="ckgx5nsfi000w0gbucasacj34"
        class="article-share-link">分享</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LeetCode/">LeetCode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Swift/">Swift</a></li></ul>

    </footer>

  </div>

  

  

  

</article>
    
    <article id="post-简单瀑布流布局实现（Swift）" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/08/27/简单瀑布流布局实现（Swift）/"
    >简单瀑布流布局实现（Swift）</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/08/27/简单瀑布流布局实现（Swift）/" class="article-date">
  <time datetime="2020-08-27T13:21:38.000Z" itemprop="datePublished">2020-08-27</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

      
      
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h3 id="写作目的"><a href="#写作目的" class="headerlink" title="写作目的"></a>写作目的</h3><p>前段时间面试，问了瀑布流布局，所以就想到写这篇文章分享一下相关的知识点。<br>瀑布流布局是一种常见的布局方式，它能够美观、灵活地展示不同高度的素材组合的视图控件。<br>瀑布流布局的特点就在于，item从上往下排列，每次item的放置位置，都是当前的最短列下方。</p>
<h3 id="主要的类"><a href="#主要的类" class="headerlink" title="主要的类"></a>主要的类</h3><ul>
<li>UICollectionView：视图</li>
<li>UICollectionViewFlowLayout：布局</li>
<li>UICollectionViewLayoutAttributes：item配置</li>
</ul>
<h3 id="需要重写的系统方法"><a href="#需要重写的系统方法" class="headerlink" title="需要重写的系统方法"></a>需要重写的系统方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1) 准备布局（第一次布局和刷新时调用）</span><br><span class="line">override func prepare</span><br><span class="line">2) 设置视图内容的尺寸</span><br><span class="line">override var collectionViewContentSize: CGSize</span><br><span class="line">3) 返回计算好的属性数组</span><br><span class="line">override func layoutAttributesForElements(in rect: CGRect) -&gt; [UICollectionViewLayoutAttributes]?</span><br></pre></td></tr></table></figure>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><h4 id="视图-amp-数据源"><a href="#视图-amp-数据源" class="headerlink" title="视图&amp;数据源"></a>视图&amp;数据源</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">import UIKit</span><br><span class="line"></span><br><span class="line">class ViewController: UIViewController, UICollectionViewDelegate, UICollectionViewDataSource &#123;</span><br><span class="line"></span><br><span class="line">    // 数据源</span><br><span class="line">    var dataArr = [Int]()</span><br><span class="line">    // 列数</span><br><span class="line">    let columnCount:Int = 3;</span><br><span class="line">    // 瀑布流布局</span><br><span class="line">    var flowLayout: WaterfallFlowLayout!</span><br><span class="line"></span><br><span class="line">    var collectionView: UICollectionView!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //MARK: - --- 视图已经加载</span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">        super.viewDidLoad()</span><br><span class="line">        // 数据源，同时也是高度值（实际项目中应根据内容计算高度）</span><br><span class="line">        self.dataArr = [300,200,300,400,100,200,300,400,100,200,300,400,100,200,300,400]</span><br><span class="line">        self.createUI()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //MARK: - --- 创建UI</span><br><span class="line">    func createUI()&#123;</span><br><span class="line">        // 创建collectionView视图 和 flowLayout布局</span><br><span class="line">        self.flowLayout = WaterfallFlowLayout()</span><br><span class="line">        self.flowLayout.dataArr = self.dataArr</span><br><span class="line">        let rect: CGRect = CGRect(origin: CGPoint(x: 0, y: 0), size: CGSize(width: SCREEN_WIDTH, height: SCREEN_HEIGHT))</span><br><span class="line">        let collectionView = UICollectionView.init(frame: rect, collectionViewLayout:self.flowLayout)</span><br><span class="line">        collectionView.delegate = self</span><br><span class="line">        collectionView.dataSource = self</span><br><span class="line">        collectionView.backgroundColor = UIColor.white</span><br><span class="line">        collectionView.register(UICollectionViewCell.self, forCellWithReuseIdentifier: &quot;HomeCell&quot;)</span><br><span class="line">        self.view.addSubview(collectionView)</span><br><span class="line">        self.collectionView = collectionView</span><br><span class="line"></span><br><span class="line">        // 设置布局属性</span><br><span class="line">        self.setWaterfallFlowLayouts()</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //MARK: - --- 设置item的布局</span><br><span class="line">    func setWaterfallFlowLayouts()&#123;</span><br><span class="line">        // 设置布局属性</span><br><span class="line">        self.flowLayout.columnCount = self.columnCount</span><br><span class="line">        // 边界</span><br><span class="line">        self.flowLayout.sectionInset = UIEdgeInsets.init(top: 10, left: 10, bottom: 10, right: 10)</span><br><span class="line">        // 设置间距</span><br><span class="line">        self.flowLayout.minimumLineSpacing = 10.0</span><br><span class="line">        self.flowLayout.minimumInteritemSpacing = 10.0</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //MARK: - --- delegate，dataSource</span><br><span class="line">    func numberOfSections(in collectionView: UICollectionView) -&gt; Int &#123;</span><br><span class="line">        return 1</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -&gt; Int &#123;</span><br><span class="line">        return self.dataArr.count</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -&gt; UICollectionViewCell &#123;</span><br><span class="line">        let cell:UICollectionViewCell = collectionView.dequeueReusableCell(withReuseIdentifier: &quot;HomeCell&quot;, for: indexPath)</span><br><span class="line">        cell.backgroundColor = .red</span><br><span class="line">        cell.layer.cornerRadius = 8</span><br><span class="line">        cell.layer.masksToBounds = true</span><br><span class="line"></span><br><span class="line">        var label: UILabel!</span><br><span class="line"></span><br><span class="line">        if let lab: UILabel = cell.contentView.subviews.last as? UILabel&#123;</span><br><span class="line">            label = lab</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            label = UILabel.init(frame: CGRect.init(x: 0, y: 0, width: 30, height: 30))</span><br><span class="line">            label.textAlignment = .center</span><br><span class="line">            cell.contentView.addSubview(label)</span><br><span class="line">            label.textColor = .white</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        label.text = &quot;\(indexPath.row)&quot;</span><br><span class="line">        return cell</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) &#123;</span><br><span class="line">        // 点击添加数据</span><br><span class="line">        self.dataArr += [300,200,300,400,100,200,300,400,100,200,300,400,100,200,300,400]</span><br><span class="line">        self.flowLayout.dataArr = self.dataArr</span><br><span class="line">        self.collectionView.reloadData()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h3><h4 id="计算布局"><a href="#计算布局" class="headerlink" title="计算布局"></a>计算布局</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">let SCREEN_WIDTH = UIScreen.main.bounds.size.width</span><br><span class="line">let SCREEN_HEIGHT = UIScreen.main.bounds.size.height</span><br><span class="line"></span><br><span class="line">class WaterfallFlowLayout: UICollectionViewFlowLayout &#123;</span><br><span class="line">    // 总列数</span><br><span class="line">    var columnCount:Int = 0</span><br><span class="line">    // 数据数组</span><br><span class="line">    var dataArr = [Int]()</span><br><span class="line">    // 整个collectionView的高度</span><br><span class="line">    private var maxH:Int?</span><br><span class="line">    //所有item的属性</span><br><span class="line">    fileprivate var layoutAttributesArray = [UICollectionViewLayoutAttributes]()</span><br><span class="line"></span><br><span class="line">    // 准备布局时调用</span><br><span class="line">    override func prepare() &#123;</span><br><span class="line">        /**</span><br><span class="line">         *  计算每个item的宽度</span><br><span class="line">         *  即：(collectionView的宽度 - 左右边距和 - item的水平间距之和) / 每行的item数量</span><br><span class="line">         */</span><br><span class="line">        let itemWidth = ((self.collectionView?.bounds.size.width)! - self.sectionInset.left - self.sectionInset.right - self.minimumInteritemSpacing * CGFloat(self.columnCount - 1)) / CGFloat.init(self.columnCount)</span><br><span class="line"></span><br><span class="line">        // 通过item的宽度，计算并设置属性</span><br><span class="line">        self.computeAttributesWithItemWidth(CGFloat(itemWidth))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ///根据itemWidth计算布局属性</span><br><span class="line">    func computeAttributesWithItemWidth(_ itemWidth:CGFloat)&#123;</span><br><span class="line"></span><br><span class="line">        // 定义一个列高数组 记录每一列的总高度（初始值都为上边距）</span><br><span class="line">        var columnHeightArr = [Int](repeating: Int(self.sectionInset.top), count: self.columnCount)</span><br><span class="line">        // 定义一个 记录每一列的item个数的数组</span><br><span class="line">        var columnItemCountArr = [Int](repeating: 0, count: self.columnCount)</span><br><span class="line"></span><br><span class="line">        // 定义一个 存储属性的临时数组</span><br><span class="line">        var attributesArray = [UICollectionViewLayoutAttributes]()</span><br><span class="line"></span><br><span class="line">        // 遍历数据计算每个item的属性并布局</span><br><span class="line">        for (index, dj_height) in self.dataArr.enumerated() &#123;</span><br><span class="line"></span><br><span class="line">            // 根据IndexPath获取Cell元素的属性</span><br><span class="line">            let attributes = UICollectionViewLayoutAttributes.init(forCellWith: IndexPath.init(item: index, section: 0))</span><br><span class="line">            // 找出最短列的下标</span><br><span class="line">            let minHeight:Int = columnHeightArr.sorted().first!</span><br><span class="line">            let column = columnHeightArr.firstIndex(of: minHeight)</span><br><span class="line"></span><br><span class="line">            // 将数据追加在最短列</span><br><span class="line">            columnItemCountArr[column!] += 1</span><br><span class="line">            // 计算该项的坐标</span><br><span class="line">            let itemX = (itemWidth + self.minimumInteritemSpacing) * CGFloat(column!) + self.sectionInset.left</span><br><span class="line">            let itemY = minHeight</span><br><span class="line">            // 计算item的高度（机型适配，注意比例缩放）</span><br><span class="line">            let itemH = dj_height</span><br><span class="line">            // 设置frame</span><br><span class="line">            attributes.frame = CGRect(x: itemX, y: CGFloat(itemY), width: itemWidth, height: CGFloat(itemH))</span><br><span class="line"></span><br><span class="line">            attributesArray.append(attributes)</span><br><span class="line">            // 累加列高</span><br><span class="line">            columnHeightArr[column!] += itemH + Int(self.minimumLineSpacing)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 找出最高列的下标</span><br><span class="line">        let maxHeight:Int = columnHeightArr.sorted().last!</span><br><span class="line">        let maxHeightColumnIndex = columnHeightArr.firstIndex(of: maxHeight)</span><br><span class="line">        // 根据最高列设置itemSize的默认值 使用总高度的平均值</span><br><span class="line">        let itemH = (maxHeight - Int(self.minimumLineSpacing) * (columnItemCountArr[maxHeightColumnIndex!] + 1)) / columnItemCountArr[maxHeightColumnIndex!]</span><br><span class="line">        self.itemSize = CGSize(width: itemWidth, height: CGFloat(itemH))</span><br><span class="line">        // 给属性数组设置数值</span><br><span class="line">        self.layoutAttributesArray = attributesArray</span><br><span class="line">        // 将最高列的行高赋值给属性，作为contentSize.Height的值</span><br><span class="line">        self.maxH = maxHeight</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 返回计算好的layoutAttributesArray数组</span><br><span class="line">    override func layoutAttributesForElements(in rect: CGRect) -&gt; [UICollectionViewLayoutAttributes]? &#123;</span><br><span class="line"></span><br><span class="line">        return self.layoutAttributesArray</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 重写设置contentSize</span><br><span class="line">    override var collectionViewContentSize: CGSize &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            return CGSize(width: (collectionView?.bounds.width)!, height: CGFloat(self.maxH!))</span><br><span class="line">        &#125;</span><br><span class="line">        set &#123;</span><br><span class="line">            self.collectionViewContentSize = newValue</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本篇文章主要是对瀑布流的原理进行概述和提供思路，不涉及网络请求，动态内容计算等方面，应该还算是简单易懂的。感兴趣童鞋的可以<a href="https://github.com/a334713698/WaterfallFlow" target="_blank" rel="noopener">Github</a>上下载，欢迎交流学习。</p>

      
      <!-- 打赏 -->
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/27/简单瀑布流布局实现（Swift）/" data-id="ckgx5nsg1002a0gbuqvwvnhpq"
        class="article-share-link">分享</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Swift/">Swift</a></li></ul>

    </footer>

  </div>

  

  

  

</article>
    
    <article id="post-2020年5月读书心得" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/05/08/2020年5月读书心得/"
    >2020年5月读书心得</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/05/08/2020年5月读书心得/" class="article-date">
  <time datetime="2020-05-08T14:18:30.000Z" itemprop="datePublished">2020-05-08</time>
</a>
      
      
      
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1geleneei4bj30bw0h4dif.jpg" alt=""><br>《原则》是一本几乎真本书都是干货的书。作者在40年的工作和生活中，有“记录”的习惯，通过记录经历总结经验，将工作和生活良好地经营和管理起来。<br>作者在书中推荐阅读“生活原则”的全部内容，并将概要与列表放在章节的最后，而“工作原则”可根据需要进行选读，则把概要与列表放在了章节的开头，这一点十分贴心。<br>这本书更适合在实践中去借鉴书中的方法，并优化创造出属于自己的原则。</p>
<p>本书的第一章主要讲述的是坐着的历程：作者白手起家创建桥水基金，并通过努力获取了不错的成绩。1982年8月，墨西哥对其债务违约（其他国家有可能也会步其后尘），而美国银行正在想墨西哥一样高风险的其他国家提供贷款。而作者认为自己是少数预见到这一情况的人，并自信地表示美国会走向一场大萧条。而事实是，美联储通过增加货币供给，以一种无通胀的方式复兴了。作者感觉像是不断地被球棒打自己的头，因为这是他在众目睽睽下的失败。这使他失去了8年的努力，回到的原点。</p>
<p>不过逆境没有阻挡作者的脚步。他又逐渐培养了新的客户，逐渐新的团队。他开始容忍逆境，并吸取教训，走向更大的成果。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本书中给我做大的感悟就是，在人生的道路上一定要有所成长，而成长的过程一定是痛苦的，一定要清楚这一点。同时对于实现目标的方式方法，不能过于固执己见，需要通过自己的反复复盘和值得信赖的人的佐证，不断提高其实现的概率，直到目标实现。</p>

      
      <!-- 打赏 -->
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/05/08/2020年5月读书心得/" data-id="ckgx5nsf400070gbuk447ps2u"
        class="article-share-link">分享</a>
      
    </footer>

  </div>

  

  

  

</article>
    
  </article>
  

  
  <nav class="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        &copy;
        2018-2020
        GG266
      </li>
      <li>
        
          Powered by
        
        
        <a href="https://hexo.io" target="_blank">Hexo</a> Theme <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul class="list-inline">
      <li>
        
        
        <ul class="list-inline">
  <li>PV:<span id="busuanzi_value_page_pv"></span></li>
  <li>UV:<span id="busuanzi_value_site_uv"></span></li>
</ul>
        
      </li>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s4.cnzz.com/z_stat.php?id=1278583018&amp;web_id=1278583018'></script>
        
      </li>
    </ul>
  </div>
</footer>
    <div class="to_top">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>
      </div>
    </main>
    
      <aside class="sidebar">
        
        <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/avatar.svg" alt="GG266的个人博客"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
      </aside>
      <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
      <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.justifiedGallery.min.js"></script>
<script src="/js/lazyload.min.js"></script>
<script src="/js/busuanzi-2.3.pure.min.js"></script>




<script>
  var ayerConfig = {
    mathjax: false
  }
</script>

<script src="/js/ayer.js"></script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">



<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>
  
  

  </div>
</body>

</html>