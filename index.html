<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
    
  <meta name="description" content="iOS coder,Machine-learning,DJ Hong的个人博客" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     GG266 Blog
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/favicon.jpg" />
  
  <link rel="stylesheet" href="/css/style.css">
  <script src="/js/pace.min.js"></script>

  

  

</head>

</html>

<body>
  <div id="app">
    <main class="content">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/a334713698"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover8.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">GG266 Blog</a></h1>
      <h2>GG266的个人博客</h2>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>

<div id="main">
  <section class="outer">
  <article class="articles">
    
    
    
    
    <article id="post-Github项目迁移" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/01/17/Github项目迁移/"
    >Github项目迁移</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/01/17/Github项目迁移/" class="article-date">
  <time datetime="2020-01-17T07:20:09.000Z" itemprop="datePublished">2020-01-17</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/Git/">Git</a>
  </div>

      
      
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>最早用QQ号作为GitHub的登录名，感觉有点low，想着重新注册一个账号，把所有项目迁移过来，找了一些网上的资料，最后在《<a href="https://dev.tencent.com/help/git-import-tencentcloud" target="_blank" rel="noopener">如何将Git仓库导入腾讯云开发者平台？</a>》上找到了解决方案。<br>我是把项目从 GitHubUserOld 迁移到 GitHubUserNew 上的。不同平台的账户，操作方式相同。<br>具体操作如下：</p>
<h3 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h3><p>首先在GitHubUserNew账号下，新建一个同名的空项目，不选择 <code>启用 README.md 文件初始化项目</code> ，以及任何 <code>License</code> 和 <code>.gitignore</code> 文件。</p>
<h3 id="克隆项目"><a href="#克隆项目" class="headerlink" title="克隆项目"></a>克隆项目</h3><p>从 GitHubUserOld 中找到需要迁移的项目，复制出项目的web URL。</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gazlxcx88jj31di0u048s.jpg" alt=""></p>
<p>确定当前路径所在，我这里是 cd 到桌面，到时候直接克隆到桌面。<br>在<code>Terminal</code>执行命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/GitHubUserOld/repo.git --bare</span><br></pre></td></tr></table></figure>
<p>操作结束后，桌面上会多出一个 <code>repo.git</code> 文件夹</p>
<h3 id="将克隆的仓库推送给新账户"><a href="#将克隆的仓库推送给新账户" class="headerlink" title="将克隆的仓库推送给新账户"></a>将克隆的仓库推送给新账户</h3><p>cd到 <code>repo.git</code> 文件夹</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd repo.git</span><br></pre></td></tr></table></figure>
<p>并 <code>push</code> 所有的分支和对象到新账户的仓库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push https://github.com/GitHubUserNew/repo.git --all</span><br></pre></td></tr></table></figure>
<p>完成后，再执行推送所有的标签。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push https://github.com/GitHubUserNew/repo.git --tags</span><br></pre></td></tr></table></figure>
<p>到此，GitHubUserOld账号下的repo就被完美地迁移到了GitHubUserNew账户下。</p>
<h3 id="克隆速度过慢问题"><a href="#克隆速度过慢问题" class="headerlink" title="克隆速度过慢问题"></a>克隆速度过慢问题</h3><p>我的某个项目达到了 <code>450M</code> 的大小，执行克隆操作的时候网速只有 <code>20k/s</code> 。如何解决克隆仓库时，网络过慢的问题呢。</p>
<p>答案是，修改hosts，添加固定的DNS解析。</p>
<h4 id="MacOS系统下的操作方式："><a href="#MacOS系统下的操作方式：" class="headerlink" title="MacOS系统下的操作方式："></a>MacOS系统下的操作方式：</h4><p>1.打开 <code>/etc/hosts</code> ，拷贝出该 <code>hosts</code> 文件；</p>
<p>2.将下列内容加入到拷贝出的 <code>hosts</code> 文件的末尾</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gazn258bapj30n80dodl3.jpg" alt=""></p>
<p>3.用拷贝出的文件替换 <code>hosts</code> 文件；</p>
<p>4.刷新DNS缓存：sudo dscacheutil -flushcache</p>
<p>参考文献：<a href="https://www.jianshu.com/p/2c18c13fbef3" target="_blank" rel="noopener">https://www.jianshu.com/p/2c18c13fbef3</a></p>

      
      <!-- 打赏 -->
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/01/17/Github项目迁移/" data-id="ck5i58g670007wbbuj1jch484"
        class="article-share-link">分享</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/git/">git</a></li></ul>

    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-2019年8月读书心得" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/08/26/2019年8月读书心得/"
    >2019年8月读书心得</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2019/08/26/2019年8月读书心得/" class="article-date">
  <time datetime="2019-08-26T08:02:45.000Z" itemprop="datePublished">2019-08-26</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/阅读/">阅读</a>
  </div>

      
      
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>距离上一次读书大约有2年了吧~那会儿花了一个月的时间读完了挺厚的两本《基督山伯爵》。阅读给人带来的最直接的好处是，可以让心静下来，遇事莫急，先过过脑，思考思考，在做决策。</p>
<p>由于种种原因吧。重新拾起阅读这个习惯选择的第一本书，是来自华为CEO任正非先生桌头的《美国陷阱》</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6d5ws7xy7j30eg0gwzl8.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6d5wrth9jj30e90elab0.jpg" alt=""></p>
<p>本书以作者弗雷德里克·皮耶鲁齐的亲身经历为依据，描述了美国利用其强大的国力“强制”实时其“长臂管辖”能力以实现其自身目的。</p>
<p>从书中的描写，我们可以看出，作者是这场隐蔽的经济战争的牺牲品、替罪羊。在他入狱之后，先后被自己的公司（法国阿尔斯通）所出卖，被自己的国家所遗忘。公司里的高管，人人只管着自保，而作者的祖国——法国，在政治上也没有任何可以谈判的筹码，只能忍气吞声。最终，阿尔斯通的CEO柏克龙以公司为筹码换取自身平安，将法国的“明珠”产业——阿尔斯通的电力产业，卖给了美国通用电气公司。</p>
<p>他们是如何做到的呢？</p>
<p>美国政府自认为有权追诉任何一家公司，只要它用美元计价签订合同，或者仅仅通过设在美国的服务器（如谷歌邮箱或微软邮箱）收发、存储（甚至只是过境）邮件，这些都被视为国际贸易工具。这就是美国人的一个把戏，他们把一项可能削弱自身企业的法律转变为干涉他国企业、发动经济战的神奇工具。<br>而到手的“罪犯”不需要是真正的幕后主使，只要美国政府愿意，那他就是。只要能达到他们的狼子野心，就可以了。</p>
<p>看完这本书，我又去查阅了“孟晚舟事件”，结果和我想的一样，这是美国故技重施的阴谋，想要通过相同的手法，对在通信领域有着举足轻重地位的中国公司“华为”入手。<br>略有不同的是，我们国家对此事高度关注，华为公司也在积极应对。</p>
<p>说到这里，忍不住想提一下中美的贸易战。作为一名普通老百姓，可能对贸易战的直观感受就是…没啥感觉，成天看新闻说贸易战，然后各种东西的涨价不知道和贸易战是否有关。不管我们相不相信，愿不愿意，这场经济战争，都已经打响了。我觉得我所能做的，就是相信我们的国家，能够在这场战斗中展现出我们的优势和强大国力。这里有一篇<br><a href="https://media.weibo.cn/article?id=2309404404008738488342" target="_blank" rel="noopener">《2019年8月中美贸易战简况总结》</a>，个人觉得还是非常值得一读的。我们承认美国拥有世界上首屈一指的国力，但是如今的中国在世界上，也是有着举足轻重的力量。</p>
<p>最后提一下。</p>
<p>《美国陷阱》这本书的前29节，我看的是实体书。我并没有购买这本书。而是在支付宝的“浙江图书馆”借阅了这本书。并且它支持邮寄（邮政+京东），到手速度非常快。<br>而后面的章节，由于出差没有带书。在某读书软件中读完了剩余的内容。感觉电子书阅读，其实也是蛮能接受的，方便随时阅读，就是看久了屏幕，眼睛有点吃力。</p>

      
      <!-- 打赏 -->
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/08/26/2019年8月读书心得/" data-id="ck5i58g5y0001wbbueitp76vo"
        class="article-share-link">分享</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/读书心得/">读书心得</a></li></ul>

    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-iOS源码阅读——YYWebImage" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2018/12/25/iOS源码阅读——YYWebImage/"
    >iOS源码阅读——YYWebImage</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2018/12/25/iOS源码阅读——YYWebImage/" class="article-date">
  <time datetime="2018-12-25T12:07:29.000Z" itemprop="datePublished">2018-12-25</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

      
      
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>加载网络图片是项目中比较常见的需求，<code>YYWebImage</code>是Github中比较好用的图片加载开源框架之一。<code>YYWebImage</code>是作者为UIImageView创建的Category，使得UIImageView的实例能够直接调用一个实例方法，就能获取网络图片的功能。</p>
<h2 id="UIImageView-YYWebImage的实例方法"><a href="#UIImageView-YYWebImage的实例方法" class="headerlink" title="UIImageView+YYWebImage的实例方法"></a>UIImageView+YYWebImage的实例方法</h2><p>在<code>UIImageView+YYWebImage</code>列举了5中方法供开发者使用，分别是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">①- (void)yy_setImageWithURL:(nullable NSURL *)imageURL placeholder:(nullable UIImage *)placeholder;</span><br><span class="line">②- (void)yy_setImageWithURL:(nullable NSURL *)imageURL options:(YYWebImageOptions)options;</span><br><span class="line">③- (void)yy_setImageWithURL:(nullable NSURL *)imageURL</span><br><span class="line">               placeholder:(nullable UIImage *)placeholder</span><br><span class="line">                   options:(YYWebImageOptions)options</span><br><span class="line">                completion:(nullable YYWebImageCompletionBlock)completion;</span><br><span class="line">④- (void)yy_setImageWithURL:(nullable NSURL *)imageURL</span><br><span class="line">               placeholder:(nullable UIImage *)placeholder</span><br><span class="line">                   options:(YYWebImageOptions)options</span><br><span class="line">                  progress:(nullable YYWebImageProgressBlock)progress</span><br><span class="line">                 transform:(nullable YYWebImageTransformBlock)transform</span><br><span class="line">                completion:(nullable YYWebImageCompletionBlock)completion;</span><br><span class="line"></span><br><span class="line">⑤- (void)yy_setHighlightedImageWithURL:(NSURL *)imageURL</span><br><span class="line">                          placeholder:(UIImage *)placeholder</span><br><span class="line">                              options:(YYWebImageOptions)options</span><br><span class="line">                              manager:(YYWebImageManager *)manager</span><br><span class="line">                             progress:(YYWebImageProgressBlock)progress</span><br><span class="line">                            transform:(YYWebImageTransformBlock)transform</span><br><span class="line">                           completion:(YYWebImageCompletionBlock)completion;</span><br></pre></td></tr></table></figure></p>
<p>从方法的具体实现中可以看到，①~④的方法实现，都是调用了方法⑤，只是参数传递有所不同。所以我们只需要着重阅读方法⑤的代码实现</p>
<h2 id="具体实现——UIImageView-YYWebImage-m"><a href="#具体实现——UIImageView-YYWebImage-m" class="headerlink" title="具体实现——UIImageView+YYWebImage.m"></a>具体实现——<a href="https://github.com/ibireme/YYWebImage/blob/master/YYWebImage/Categories/UIImageView%2BYYWebImage.m" target="_blank" rel="noopener">UIImageView+YYWebImage.m</a></h2><ol>
<li>判断传入的图片链接如果是NSString类型的实例，要先转换为NSURL类型的实例</li>
<li>三目运算，判断<code>YYWebImageManager</code>实例初始化与否，确保初始化完成</li>
<li><p>_YYWebImageSetter</p>
<ol>
<li>关于<code>_YYWebImageSetter</code>，作者的注解是：Private class used by web image categories.Typically, you should not use this class directly.它是Web图像类别使用的私有类。通常，您不应直接使用此类。</li>
<li>包含2个只读属性、和4个方法<ol>
<li>属性：（NSURL*）imageURL、(int32_t) sentinel</li>
<li>方法：<ol>
<li>-(int32_t)setOperationWithSentinel: url: options: manager: progress: transform: completion:</li>
<li>-(int32_t)cancel</li>
<li>-(int32_t)cancelWithNewURL:</li>
<li>+(dispatch_queue_t)setterQueue</li>
</ol>
</li>
<li><code>objc_getAssociatedObject</code>：通过runtime获取UIImageView的动态属性setter，类型为<code>_YYWebImageSetter</code>。</li>
<li>如果获取到的setter为空，则需要新建一个_YYWebImageSetter实例，并动态关联这个属性。</li>
<li>[setter cancelWithNewURL:imageURL]通过新的图片链接，取消原来的线程操作。实现步骤：<ol>
<li>dispatch_semaphore_wait(_lock, DISPATCH_TIME_FOREVER)如果_lock的信号量值为0，则线程阻塞，不往下执行。否则，信号量-1（初始信号量为1），继续往下执行。</li>
<li>判断 _operation线程是否存在，如果存在，取消这个线程，并置空。</li>
<li>为 _imageURL变量赋值——新的图片连接</li>
<li>sentinel = OSAtomicIncrement32(&amp;_sentinel);值自增</li>
<li>dispatch_semaphore_signal(_lock) 信号量+1</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>_yy_dispatch_sync_on_main_queue确保在主线程执行后面的代码。</p>
<ol>
<li>从内存缓存<code>YYImageCacheTypeMemory</code>中获取图片，如果获取成功，则执行complete()，结束操作。</li>
<li>未在内存缓存中获取到图片，继续执行。<ol>
<li>通过 [_YYWebImageSetter setterQueue]，获取到一个与全局队列优先级相同的队列，并异步执行后面的代码</li>
<li>预先创建和实现的  YYWebImageCompletionBlock _completion block。</li>
<li>实现 _YYWebImageSetter *setter的实例方法—— [setter setOperationWithSentinel:sentinel url:imageURL options:options manager:manager progress:_progress transform:transform completion:_completion]。</li>
<li>通过一路追随 _completion block的传递，发现进入了  YYWebImageOperation  类。</li>
<li>YYWebImageOperation继承于 NSOperation。作者重写了NSOpration类的start，方法。并在恰当时机调用了自定义方法 _startOperation。</li>
<li>_startOperation方法的实现<ol>
<li>当_cache存在且用户没有设置  YYWebImageOptionUseNSURLCache 和  YYWebImageOptionRefreshImageCache 选项。会先去取图片缓存。</li>
<li>获取内存图片缓存，调用方法 [_cache getImageForKey:_cacheKey withType:YYImageCacheTypeMemory];。通过_cacheKey获取内存缓存。如果获取成功，结束后台线程；获取失败，则向下执行</li>
<li>当用户没有设置忽略磁盘缓存 YYWebImageOptionIgnoreDiskCache，则接下去，从磁盘获取图片缓存。</li>
<li>获取磁盘图片缓存，调用方法 [self.cache getImageForKey:self.cacheKey withType:YYImageCacheTypeDisk]。<ol>
<li>如果从磁盘获取图片缓存成功，先将图片缓存到内存，并调用 _didReceiveImageFromDiskCache方法。</li>
<li>如果同磁盘获取图片缓存失败，则需要从网络请求图片数据。</li>
</ol>
</li>
<li>通过网络请求获取图片。<ol>
<li>通过 incrementNetworkActivityCount为请求数量+1</li>
<li>通过 connection: didReceiveData: 方法的回调，不断地获取数据。</li>
<li>在 connectionDidFinishLoading 的方法回调中，调用 _didReceiveImageFromWeb 方法。</li>
<li>通过 decrementNetworkActivityCount 为请求数量-1</li>
</ol>
</li>
<li><ol>
<li>_didReceiveImageFromWeb成功从网络获取图片。将图片分别存入内存和磁盘缓存中。</li>
</ol>
</li>
<li>回到之前实现的 _completion代码块。主要是一些动画特效。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>通过<code>completion:(nullable YYWebImageCompletionBlock)completion</code>，将结果返回给开发者</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>YYWebImage</code>的实现合乎我们的直觉：</p>
<ul>
<li>查看缓存（1.内存；2.磁盘）<ul>
<li>缓存命中<ul>
<li>返回图片</li>
<li>更新视图</li>
</ul>
</li>
<li>缓存未命中<ul>
<li>异步下载图片</li>
<li>加入缓存</li>
<li>更新视图</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h3><p>之前尝试阅读过<code>YYWebImage</code>框架，当时的方法是一个类一个类看，从.h的属性、方法，到.m的具体实现。说实话，看起来着实有点烧脑和低效。读了<a href="https://github.com/draveness/analyze" target="_blank" rel="noopener">Draven</a>的《<a href="https://github.com/draveness/analyze/blob/master/contents/SDWebImage/iOS%20%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%20---%20SDWebImage.md" target="_blank" rel="noopener">iOS 源代码分析 — SDWebImage</a>》，有所启发，直接以API作为入口阅读源码，更具方向性，才会更有收获。<br>文章中涉及到了<a href="https://www.cnblogs.com/snailHL/p/3906112.html" target="_blank" rel="noopener">dispatch_semaphore</a>、<a href="https://www.jianshu.com/p/8f07a9bdd1cd" target="_blank" rel="noopener">队列优先级</a>的知识。</p>

      
      <!-- 打赏 -->
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/12/25/iOS源码阅读——YYWebImage/" data-id="ck5i58g6m000pwbbulimw8awh"
        class="article-share-link">分享</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/YYWebImage/">YYWebImage</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码阅读/">源码阅读</a></li></ul>

    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-iOS-UITableView-长按移动Cell的位置" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2018/11/30/iOS-UITableView-长按移动Cell的位置/"
    >iOS UITableView 长按移动Cell的位置</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2018/11/30/iOS-UITableView-长按移动Cell的位置/" class="article-date">
  <time datetime="2018-11-30T11:49:23.000Z" itemprop="datePublished">2018-11-30</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

      
      
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h3 id="实现思路："><a href="#实现思路：" class="headerlink" title="实现思路："></a>实现思路：</h3><ol>
<li>长按获取当前手指所在位置的indexPath</li>
<li>通过indexPath获取对应cell，并生成快照</li>
<li>移动。<br>3.1. 快照跟随手指移动<br>3.2. 当手指移动到其他cell的位置时，执行位置互换，和数据互换</li>
<li>放开手指，移除快照</li>
</ol>
<p><br></p>
<h3 id="实现步骤："><a href="#实现步骤：" class="headerlink" title="实现步骤："></a>实现步骤：</h3><p>准备：(UITableView<em>)tableView，数据源(NSMutableArray</em>)lists</p>
<h5 id="第一步：为tableView添加长按手势"><a href="#第一步：为tableView添加长按手势" class="headerlink" title="第一步：为tableView添加长按手势"></a>第一步：为tableView添加长按手势</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UILongPressGestureRecognizer* longRec = [[UILongPressGestureRecognizer alloc] initWithTarget:self action:@selector(longPress:)];</span><br><span class="line">[_tableView addGestureRecognizer:longRec];</span><br></pre></td></tr></table></figure>
<h5 id="第二步：实现手势对应的操作。"><a href="#第二步：实现手势对应的操作。" class="headerlink" title="第二步：实现手势对应的操作。"></a>第二步：实现手势对应的操作。</h5><p>① <code>UIGestureRecognizerStateBegan</code> 时，选中cell。<br>通过手势在tableView的location，可以获取到tableView上对应的IndexPath，从而也能获取到对应的cell。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//UIGestureRecognizer 的实例方法，可获取手势在载体上的点坐标</span><br><span class="line">- (CGPoint)locationInView:(nullable UIView*)view;</span><br><span class="line"></span><br><span class="line">//UITableView 的实例方法，可获取屏幕上某个点下存在的indexPath</span><br><span class="line">- (nullable NSIndexPath *)indexPathForRowAtPoint:(CGPoint)point;</span><br><span class="line"></span><br><span class="line">//UIView 的实例方法，可生成屏幕快照，要求iOS 7.0+</span><br><span class="line">- (nullable UIView *)snapshotViewAfterScreenUpdates:(BOOL)afterUpdates;</span><br></pre></td></tr></table></figure></p>
<p>② <code>UIGestureRecognizerStateChanged</code> 时，移动cell。<br>通过手势在移动中，不断的回调，获取相应的位置，当手势移动到其他cell的位置时，就可以进行数据和视图的对调。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//NSMutableArray 的实例方法，可快速交换数组中两个对象的位置</span><br><span class="line">- (void)exchangeObjectAtIndex:(NSUInteger)idx1 withObjectAtIndex:(NSUInteger)idx2;</span><br><span class="line"></span><br><span class="line">//UITableView 的实例方法，可快速交换两个cell的位置，带动画</span><br><span class="line">- (void)moveRowAtIndexPath:(NSIndexPath *)indexPath toIndexPath:(NSIndexPath *)newIndexPath;</span><br><span class="line"></span><br><span class="line">//UITableView 的实例方法，可快速交换两个section的位置，带动画</span><br><span class="line">- (void)moveSection:(NSInteger)section toSection:(NSInteger)newSection;</span><br></pre></td></tr></table></figure></p>
<p>③ <code>UIGestureRecognizerStateEnded</code> 时：放下cell，移除快照</p>
<p><br></p>
<p>完整的<code>longPress:</code>方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">- (void)longPress:(UILongPressGestureRecognizer*)sender&#123;</span><br><span class="line">    UIGestureRecognizerState state = sender.state;</span><br><span class="line">    CGPoint location = [sender locationInView:_tableView];</span><br><span class="line">    switch (state) &#123;</span><br><span class="line">        case UIGestureRecognizerStateBegan:&#123;</span><br><span class="line">            NSLog(@&quot;选中cell&quot;);</span><br><span class="line">            _selectIndexPath = [_tableView indexPathForRowAtPoint:location];</span><br><span class="line">            if (!_selectIndexPath) return;</span><br><span class="line">            UITableViewCell* cell = [_tableView cellForRowAtIndexPath:_selectIndexPath];</span><br><span class="line">            _snapShot = [self snapshotViewAfterScreenUpdates:cell];</span><br><span class="line">            _snapShot.frame = CGRectMake(0, location.y, _snapShot.bounds.size.width, _snapShot.bounds.size.height);</span><br><span class="line">            [self.view addSubview:_snapShot];</span><br><span class="line">            cell.contentView.hidden = YES;</span><br><span class="line">        &#125;</span><br><span class="line">            break;</span><br><span class="line">        case UIGestureRecognizerStateChanged:&#123;</span><br><span class="line">            NSLog(@&quot;移动cell&quot;);</span><br><span class="line">            _snapShot.frame = CGRectMake(0, location.y, _snapShot.bounds.size.width, _snapShot.bounds.size.height);</span><br><span class="line">            NSIndexPath* changeIndexPath = [_tableView indexPathForRowAtPoint:location];</span><br><span class="line">            if (!_selectIndexPath || !changeIndexPath) return;</span><br><span class="line">            if (_selectIndexPath != changeIndexPath) &#123;</span><br><span class="line">                NSLog(@&quot;交换&quot;);</span><br><span class="line">                [self.lists exchangeObjectAtIndex:_selectIndexPath.row withObjectAtIndex:changeIndexPath.row];</span><br><span class="line">                //移动Section —— [self.tableView moveSection:0 toSection:0];</span><br><span class="line">                //移动row</span><br><span class="line">                [self.tableView moveRowAtIndexPath:_selectIndexPath toIndexPath:changeIndexPath];</span><br><span class="line">                UITableViewCell* selectCell = [_tableView cellForRowAtIndexPath:_selectIndexPath];</span><br><span class="line">                UITableViewCell* changeCell = [_tableView cellForRowAtIndexPath:changeIndexPath];</span><br><span class="line">                selectCell.contentView.hidden = NO;</span><br><span class="line">                changeCell.contentView.hidden = YES;</span><br><span class="line">                _selectIndexPath = changeIndexPath;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            break;</span><br><span class="line">        case UIGestureRecognizerStateEnded:&#123;</span><br><span class="line">            NSLog(@&quot;放下cell&quot;);</span><br><span class="line">            [_snapShot removeFromSuperview];</span><br><span class="line">            _snapShot = nil;</span><br><span class="line">            if (!_selectIndexPath) return;</span><br><span class="line">            UITableViewCell* cell = [_tableView cellForRowAtIndexPath:_selectIndexPath];</span><br><span class="line">            cell.contentView.hidden = NO;</span><br><span class="line">            _selectIndexPath = nil;</span><br><span class="line">        &#125;</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><a href="https://github.com/a334713698/DragSort" target="_blank" rel="noopener">Demo</a></p>

      
      <!-- 打赏 -->
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/30/iOS-UITableView-长按移动Cell的位置/" data-id="ck5i58g6i000jwbbu6nj7x6bf"
        class="article-share-link">分享</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/UITableView/">UITableView</a></li></ul>

    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-自定义UITableView左滑删除样式" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2018/09/07/自定义UITableView左滑删除样式/"
    >自定义UITableView左滑删除样式</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2018/09/07/自定义UITableView左滑删除样式/" class="article-date">
  <time datetime="2018-09-07T08:57:59.000Z" itemprop="datePublished">2018-09-07</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

      
      
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>最近在做番茄钟的项目，其中涉及到任务列表的界面，希望实现左滑删除的功能。UITableViewDelegate自带简单的左滑删除的接口，通过实现<code>canEditRowAtIndexPath方法</code>打开tableView可编辑的开关，再实现<code>editActionsForRowAtIndexPath方法</code>处理事件，<code>UITableViewRowAction</code>的实例允许修改文字和背景色。<br><img src="https://ws1.sinaimg.cn/large/0069RVTdgy1fv11c5vl0gj30lu05cdj5.jpg" alt=""></p>
<p>而我的需求是想把删除键做成一个垃圾桶图标。而系统没有直接可用的API，那就只能曲线救国了。</p>
<p>首先，这个删除按钮在 iOS11 和 iOS11以下的系统中，所处的父级是不一样的。</p>
<h2 id="在iOS11以前"><a href="#在iOS11以前" class="headerlink" title="在iOS11以前"></a>在iOS11以前</h2><p>删除按钮的父级是cell图。<br><img src="https://ws2.sinaimg.cn/large/0069RVTdgy1fv11nwlk64j319g0lc7fn.jpg" alt=""></p>
<h2 id="iOS11"><a href="#iOS11" class="headerlink" title="iOS11+"></a>iOS11+</h2><p>删除按钮的父级类名为<code>UISwipeActionPullView</code>，<code>UISwipeActionPullView</code>的父级为<code>UITableViewRowAction</code>，也就是说<code>UISwipeActionPullView</code>和cell是同级的。<br><img src="https://ws3.sinaimg.cn/large/0069RVTdgy1fv11nwb7dpj31ae0jkds6.jpg" alt=""></p>
<p>所以，两者需要以不同的方式实现。</p>
<p>在两种系统中，当还未左滑调出删除按钮时，输出cell或tableView的所有子视图，发现并没有删除按钮的存在。也就是说，他们是在需要的时候，被创建出来的。所以，我们需要重写某个方法去截获这个删除按钮。</p>
<h2 id="在iOS11以前-1"><a href="#在iOS11以前-1" class="headerlink" title="在iOS11以前"></a>在iOS11以前</h2><p>重写<code>insertSubview:atIndex</code>方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (void)insertSubview:(UIView *)view atIndex:(NSInteger)index &#123;</span><br><span class="line">    [super insertSubview:view atIndex:index];</span><br><span class="line">    DLog(@&quot;insertSubview&quot;);</span><br><span class="line">    if ([view isKindOfClass:NSClassFromString(@&quot;UITableViewCellDeleteConfirmationView&quot;)]) &#123;</span><br><span class="line">        for (UIButton *btn in view.subviews) &#123;</span><br><span class="line"></span><br><span class="line">            if ([btn isKindOfClass:[UIButton class]]) &#123;</span><br><span class="line">                [btn setBackgroundColor:[UIColor clearColor]];</span><br><span class="line">                [btn mas_updateConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">                    make.width.mas_equalTo(adaptWidth(35));</span><br><span class="line">                    make.height.mas_equalTo(adaptWidth(35));</span><br><span class="line">                    make.centerX.mas_equalTo(0);</span><br><span class="line">                    make.centerY.mas_equalTo(0);</span><br><span class="line">                &#125;];</span><br><span class="line"></span><br><span class="line">                [btn setTitle:nil forState:UIControlStateNormal];</span><br><span class="line">                UIImage *img = [IMAGE(@&quot;list_deleting&quot;) imageForThemeColor:[UIColor redColor]];</span><br><span class="line">                [btn setImage:img forState:UIControlStateNormal];</span><br><span class="line">                [btn setImage:img forState:UIControlStateHighlighted];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="iOS11-1"><a href="#iOS11-1" class="headerlink" title="iOS11+"></a>iOS11+</h2><p>新建并使用一个继承于UITableView的控件，重写<code>layoutSubviews</code>方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (void)layoutSubviews&#123;</span><br><span class="line">    [super layoutSubviews];</span><br><span class="line"></span><br><span class="line">    //iOS11版本以上,自定义删除按钮:</span><br><span class="line">    if ([[[UIDevice currentDevice] systemVersion] doubleValue] &gt;= 11.0) &#123;</span><br><span class="line">        for (UIView *subview in self.subviews)</span><br><span class="line">        &#123;</span><br><span class="line">            if([subview isKindOfClass:NSClassFromString(@&quot;UISwipeActionPullView&quot;)])</span><br><span class="line">            &#123;</span><br><span class="line">                UIView *swipeActionPullView = subview;</span><br><span class="line">                swipeActionPullView.backgroundColor =  [UIColor clearColor];</span><br><span class="line"></span><br><span class="line">                UIButton *swipeActionStandardBtn = subview.subviews[0];</span><br><span class="line">                if ([swipeActionStandardBtn isKindOfClass:NSClassFromString(@&quot;UISwipeActionStandardButton&quot;)]) &#123;</span><br><span class="line"></span><br><span class="line">                    [swipeActionStandardBtn mas_updateConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">                        make.width.mas_equalTo(adaptWidth(35));</span><br><span class="line">                        make.height.mas_equalTo(adaptWidth(35));</span><br><span class="line">                        make.left.mas_equalTo(0);</span><br><span class="line">                        make.centerY.mas_equalTo(0);</span><br><span class="line">                    &#125;];</span><br><span class="line">                    [swipeActionStandardBtn setTitle:nil forState:UIControlStateNormal];</span><br><span class="line">                    [swipeActionStandardBtn setImage:[IMAGE(@&quot;list_deleting&quot;) imageForThemeColor:[UIColor redColor]] forState:UIControlStateNormal];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>*在iOS11以前，左滑cell不会走<code>layoutSubviews</code>的方法。在iOS11上，左滑时tableView不会走<code>insertSubview:atIndex</code>方法。</p>
<p><img src="https://ws2.sinaimg.cn/large/0069RVTdgy1fv12w0xbwqj30lm05gade.jpg" alt=""></p>

      
      <!-- 打赏 -->
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/07/自定义UITableView左滑删除样式/" data-id="ck5i58g6q000ywbbu7f0dj8b9"
        class="article-share-link">分享</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/UITableView/">UITableView</a></li></ul>

    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-Diary" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2018/09/05/Diary/"
    >Diary</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2018/09/05/Diary/" class="article-date">
  <time datetime="2018-09-05T06:28:00.000Z" itemprop="datePublished">2018-09-05</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/随记/">随记</a>
  </div>

      
      
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h3 id="2018年9月5日-周三"><a href="#2018年9月5日-周三" class="headerlink" title="2018年9月5日 周三"></a>2018年9月5日 周三</h3><hr>
<p>今天尝试着将小程序上传提交审核了。<br>从8月8日创建项目开始，历时将近一个月时间，算是做了点东西出来。<br>一个产品在设计伊始应该先有个原型，但是我不是产品经理，所以我就用Page画了一些简单的图形，来提现界面的雏形。<br>然后…然后就直接上手开发了。<br>可发过程中也遇到了很多问题，例如如何获取小程序的全局变量，如何去适配屏幕的高宽，单位的使用，是用px，还是rpx，等等，等等<br>不过好在，所有这些问题，在搜索引擎的帮助下基本都能解决。<br>对JS的感觉是，既陌生又熟悉，因为同时在学习Swift的缘故，发现二者还是有一些相似之处。<br>HTML和CSS是上大学那会儿学的，写的时候，还是不得不时不时查阅文档才能达到想要的效果。<br>最近，腾讯还上线了云开发，但是目前还在公测阶段，需要申请公测资格，我填写了好几次信息，都没有收到允许公测的邮件..<br>所有后面直接用了Bomb的后台云。<br>Bomb后端云的免费版每月有10万次的API调用额度，20GB的存储空间，20GB的流量，以及30条短信。<br>如果用完了或者不够用，也可以按需充值。还是蛮方便的<br>这个小项目下做来，有些感慨，在做事情之前，还是应该有相对充分的准备。<br>对于不熟悉的语言，按需学习做项目的方式，会让人特别难受，特别是前期，还处于摸索的阶段，基本上是五行代码一小查，十行代码一大查的状态。<br>小程序的页面花了大概三周的时间，每天基本只用半天的时间去写（下午学习Swift），9个页面，包括信息的展示页面，和信息的发布界面，以及个人中心页面，最后只用来两个信息展示页面…内容的展示姑且先用CVS记录，再导入数据库进行管理。是骡子是马，先拉出去溜溜看吧。<br>估计在小程序上线过程中，还会遇到一些问题，不知道会不会因为功能过于简单，直接不让上了…<br><br></p>
<h3 id="2018年9月2日-周一"><a href="#2018年9月2日-周一" class="headerlink" title="2018年9月2日 周一"></a>2018年9月2日 周一</h3><hr>
<p>使用Bomb作为小程序的后端，在线编辑数据库，亦可导入cvs的文件，非常方便使用。<br>不需要自己写后端代码，甚至连服务器都不需要部署跟购买，在满足需求的程度上够用了。</p>
<p><br></p>
<h3 id="2018年2月11日-周日"><a href="#2018年2月11日-周日" class="headerlink" title="2018年2月11日 周日"></a>2018年2月11日 周日</h3><hr>
<p>添加了Livere评论控件，从此以后文章可以被评论了：）</p>
<p><br></p>
<h3 id="2018年2月9日-周五"><a href="#2018年2月9日-周五" class="headerlink" title="2018年2月9日 周五"></a>2018年2月9日 周五</h3><hr>
<p>发现博客首页的_content内容摘要部分部分，无法点击进入文章详情。今天就在archer主题的文件里做了个小改动，实现内容的点击事件<br>实现方法也非常简单。首先需要找到首页的布局文件,其文件目录大概是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/blogRootDir/themes/archer/layout/index.ejs</span><br></pre></td></tr></table></figure></p>
<p>使用文档编辑器打开<code>index.ejs</code>文件，找到以下内容：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"abstract-content"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%-</span> <span class="attr">_content</span> %&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>改成如下代码，就搞定了：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"abstract-title"</span> <span class="attr">href</span> = <span class="string">"&lt;%- url_for(_post.path) %&gt;"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"abstract-content"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">%-</span> <span class="attr">_content</span> %&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="2018年2月8日-周四"><a href="#2018年2月8日-周四" class="headerlink" title="2018年2月8日 周四"></a>2018年2月8日 周四</h3><hr>
<p>今天写下第一篇，和技术有一点点关系的博客。虽然大部分内容是通过粘贴和借鉴的。不过在排版和Markdown的语法上，还是得到了学习。<br>想对自己说，再接再厉吧。<br>以后想通过Diary这个页面，记录自己生活和学习的点滴，希望在未来的某一天，能看到自己逐步地成长。</p>

      
      <!-- 打赏 -->
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/05/Diary/" data-id="ck5i58g620003wbbu94m7s0iw"
        class="article-share-link">分享</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Diary/">Diary</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Life/">Life</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/成长/">成长</a></li></ul>

    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-使用Xcode的Instruments-Leaks-监测App的内存泄漏问题" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2018/06/20/使用Xcode的Instruments-Leaks-监测App的内存泄漏问题/"
    >使用Xcode的Instruments(Leaks)监测App的内存泄漏问题</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2018/06/20/使用Xcode的Instruments-Leaks-监测App的内存泄漏问题/" class="article-date">
  <time datetime="2018-06-20T08:58:13.000Z" itemprop="datePublished">2018-06-20</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

      
      
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>最近项目提交App Store审核，有些闲暇时间，打算用Instruments工具里的Leaks<br>检查一下项目中存在的内存泄漏问题。</p>
<h4 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h4><h5 id="1-edit-scheme"><a href="#1-edit-scheme" class="headerlink" title="1.edit scheme"></a>1.edit scheme</h5><p>修改为测试环境<br><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gayq6uqwk2j30jk0e4gnd.jpg" alt=""><br>将Profile中的Build Configuration选为Debug<br><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gayq6ull6nj31ds0s0whn.jpg" alt=""></p>
<h5 id="2-Debug-Information-Format"><a href="#2-Debug-Information-Format" class="headerlink" title="2.Debug Information Format"></a>2.Debug Information Format</h5><p>设置调试运行的时候生成 dSYM文件（用于代码定位）</p>
<p><code>Build Settings --&gt; Debug Information Format</code></p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gayqazbj7qj31jn0u0k00.jpg" alt=""></p>
<h4 id="二、开始监测"><a href="#二、开始监测" class="headerlink" title="二、开始监测"></a>二、开始监测</h4><h5 id="1-打开Instruments"><a href="#1-打开Instruments" class="headerlink" title="1.打开Instruments"></a>1.打开Instruments</h5><p>在Xcode的导航栏中找到Instruments。</p>
<p><code>Xcode --&gt; Open Developer Tool --&gt; Instruments</code></p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gayqbb0inkj30qg0gegsf.jpg" alt=""></p>
<h5 id="2-双击选择Leaks"><a href="#2-双击选择Leaks" class="headerlink" title="2.双击选择Leaks"></a>2.双击选择Leaks</h5><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gayqbamrugj316s0o278d.jpg" alt=""></p>
<h5 id="3-选择设备和项目"><a href="#3-选择设备和项目" class="headerlink" title="3.选择设备和项目"></a>3.选择设备和项目</h5><p>找到运行的设备和正在运行的项目。</p>
<p>选好设备和项目，点击左侧的大红点，项目会在对应的设备中重新运行一次。并做好监测准备<br><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gayqbac3owj31ka0u0n43.jpg" alt=""></p>
<h5 id="4-内存监测"><a href="#4-内存监测" class="headerlink" title="4.内存监测"></a>4.内存监测</h5><p>由于Leaks是动态监测，所以需要一边手动操作App，一边观察Leaks界面上的变化。当出现红色叉叉时，说明出现了内存泄漏，可以暂停进程，进行查看<br><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gayqba1hkvj30sc0kg40a.jpg" alt=""></p>
<p>5.定位内存泄漏的位置<br>选择 <code>Leaks ——&gt; Call Tree</code>，最底下会出现4个选框<br><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gayqcb41w2j31gu0u0wjr.jpg" alt=""></p>
<p>5.1 点击第二个<code>Call Tree</code>，勾选 <code>Invert Call Tree</code> 和 <code>Hide System Libraries</code></p>
<p><strong>勾选前</strong><br><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gayqcan6nrj31ha0u0n3k.jpg" alt=""></p>
<p><strong>勾选后</strong><br><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gayqc9pgknj31hj0u0aj8.jpg" alt=""></p>
<h5 id="6-确认位置，修改代码"><a href="#6-确认位置，修改代码" class="headerlink" title="6.确认位置，修改代码"></a>6.确认位置，修改代码</h5><p>此时显示的就是若干条内存泄漏的代码部分，选择其中一条双击，即可显示代码。还可直接跳转到代码在Xcode中额具体位置<br><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gayqc9daqlj31hc0u0gw8.jpg" alt=""></p>

      
      <!-- 打赏 -->
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/06/20/使用Xcode的Instruments-Leaks-监测App的内存泄漏问题/" data-id="ck5i58g6g000fwbbudzt57zk3"
        class="article-share-link">分享</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Instruments/">Instruments</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Leaks/">Leaks</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Xcode/">Xcode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/内存泄漏/">内存泄漏</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/调试优化/">调试优化</a></li></ul>

    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-RunLoop实践" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2018/03/04/RunLoop实践/"
    >RunLoop实践</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2018/03/04/RunLoop实践/" class="article-date">
  <time datetime="2018-03-04T07:20:43.000Z" itemprop="datePublished">2018-03-04</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

      
      
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h4 id="（一）RunLoop的用途"><a href="#（一）RunLoop的用途" class="headerlink" title="（一）RunLoop的用途"></a>（一）RunLoop的用途</h4><h5 id="1-常驻线程"><a href="#1-常驻线程" class="headerlink" title="1.常驻线程"></a>1.常驻线程</h5><ul>
<li>保证线程不死。</li>
<li>一般来说执行完任务的线程会被销毁。而被strong强引用的线程执行完任务也会进入销亡状态，也无法使用了</li>
<li>所以可以通过RunLoop使线程常驻</li>
<li>RunLoop底层是一个死循环，但是它能监听到外部的事件</li>
<li>注意：如果一个RunLoop不包含任何Timer、Source、Observer。就会自我销亡。</li>
<li>子线程里的RunLoop启动需要满足两个条件</li>
<li>RunLoop中有东西</li>
<li>手动run（启动）</li>
<li>启动RunLoop之前，最好用@autoreleasepool{}包住</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">[super viewDidLoad];</span><br><span class="line"></span><br><span class="line">//创建线程</span><br><span class="line">self.thread = [[NSThread alloc]initWithTarget:self selector:@selector(run) object:nil];</span><br><span class="line">//开始执行线程任务</span><br><span class="line">[self.thread start];</span><br><span class="line">&#125;</span><br><span class="line">-(void)run&#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;------run-----&quot;);</span><br><span class="line"></span><br><span class="line">@autoreleasepool&#123;</span><br><span class="line">//每条线程都有唯一的与之对应的RunLoop对象</span><br><span class="line">//获取（创建）当前子线程的RunLoop</span><br><span class="line">//并为RunLoop添加 Source事件源(有基于Port的数据源)</span><br><span class="line">//如果RunLoop不包含任何Timer、Source、Observer，它就会自我销亡</span><br><span class="line">[[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:NSDefaultRunLoopMode];</span><br><span class="line">//启动当前RunLoop，使其保持运行状态（即底层死循环），但依旧能监听外部事件</span><br><span class="line">[[NSRunLoop currentRunLoop] run];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;这句话，按道理是执行不到的&quot;);</span><br><span class="line">&#125;</span><br><span class="line">-(void)test&#123;</span><br><span class="line">NSLog(@&quot;--------test--%@&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;</span><br><span class="line">-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">//在同一个线程中执行test方法</span><br><span class="line">[self performSelector:@selector(test) onThread:self.thread withObject:nil waitUntilDone:NO];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="（二）RunLoop面试题"><a href="#（二）RunLoop面试题" class="headerlink" title="（二）RunLoop面试题"></a>（二）RunLoop面试题</h4><h5 id="1-什么是RunLoop"><a href="#1-什么是RunLoop" class="headerlink" title="1.什么是RunLoop"></a>1.什么是RunLoop</h5><ul>
<li>从字面看：就是运行循环</li>
<li>从内部看，就是do-while循环，在这个循环内部不断地处理各种任务（比如Source、Timer、Observer）</li>
<li>一个线程对应一个RunLoop，主线程的RunLoop默认已经启动，子线程的RunLoop需要手动启动（调用run方法）</li>
<li>RunLoop只能选择一个模式启动，如果当前RunLoop没有任何内容，RunLoop将自动退出内部循环</li>
</ul>
<h5 id="2-为RunLoop添加的自动释放池什么时候释放"><a href="#2-为RunLoop添加的自动释放池什么时候释放" class="headerlink" title="2.为RunLoop添加的自动释放池什么时候释放"></a>2.为RunLoop添加的自动释放池什么时候释放</h5><ul>
<li>在RunLoop顺面之前释放（kCFRunLoopBeforeWaiting）</li>
</ul>
<h5 id="3-使用场景"><a href="#3-使用场景" class="headerlink" title="3.使用场景"></a>3.使用场景</h5><ul>
<li>开启常驻线程（让一个子线程不进入销亡状态，等待其他线程发来消息，处理其他事件）</li>
<li>在子线程开启一个定时器</li>
<li>在子线程中进行一些长期监控</li>
<li>可以控制定时器在特定模式下执行</li>
<li>可以让某些事件（行为、任务）在特定模式下执行</li>
<li>可以添加Observer监听RunLoop的状态，比如监听点击事件的处理（在所有点击事件之前做一些事情）</li>
</ul>

      
      <!-- 打赏 -->
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/04/RunLoop实践/" data-id="ck5i58g6d000ewbbupxg50whq"
        class="article-share-link">分享</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RunLoop/">RunLoop</a></li></ul>

    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-RunLoop理论" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2018/03/04/RunLoop理论/"
    >RunLoop理论</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2018/03/04/RunLoop理论/" class="article-date">
  <time datetime="2018-03-04T07:20:39.000Z" itemprop="datePublished">2018-03-04</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

      
      
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h4 id="（一）概念"><a href="#（一）概念" class="headerlink" title="（一）概念"></a>（一）概念</h4><ul>
<li>运行循环</li>
<li>保持程序持续运行</li>
<li>处理app的各种事件（比如触摸事件、定时器事件、Selector事件）</li>
</ul>
<h5 id="1-RunLoop与线程"><a href="#1-RunLoop与线程" class="headerlink" title="1.RunLoop与线程"></a>1.RunLoop与线程</h5><ul>
<li>每条线程都有唯一的与之对应的RunLoop对象</li>
<li>主线程的RunLoop是自动创建好的，子线程的RunLoop需要手动创建</li>
<li>RunLoop在第一次获取时创建，在线程结束时销毁。而如果该RunLoop不包含任何Timer、Source、Observer，它就会自我销亡</li>
</ul>
<h4 id="（二）RunLoop相关类"><a href="#（二）RunLoop相关类" class="headerlink" title="（二）RunLoop相关类"></a>（二）RunLoop相关类</h4><ul>
<li>在 CoreFoundation 里面关于 RunLoop 有5个类:</li>
<li>CFRunLoopRef</li>
<li>CFRunLoopModeRef</li>
<li>CFRunLoopSourceRef：事件源</li>
<li>CFRunLoopTimerRef：基于时间的触发器</li>
<li>CFRunLoopObserverRef：观察者</li>
</ul>
<h5 id="1-获取RunLoop对象"><a href="#1-获取RunLoop对象" class="headerlink" title="1.获取RunLoop对象"></a>1.获取RunLoop对象</h5><ul>
<li>Foundation</li>
<li>[NSRunLoop currentRunLoop]; //获取当前线程的RunLoop对象</li>
<li>[NSRunLoop mainRunLoop]; //获得主线程的RunLoop对象</li>
<li>Core Foundation</li>
<li>CFRunLoopGetCurrent(); //获取当前线程的RunLoop对象</li>
<li>CFRunLoopGetMain(); //获得主线程的RunLoop对象</li>
</ul>
<h4 id="（三）CFRunLoopModeRef"><a href="#（三）CFRunLoopModeRef" class="headerlink" title="（三）CFRunLoopModeRef"></a>（三）CFRunLoopModeRef</h4><h5 id="1-常用Mode"><a href="#1-常用Mode" class="headerlink" title="1.常用Mode"></a>1.常用Mode</h5><ul>
<li>NSDefaultRunLoopMode：App的默认Mode，通常主线程是在这个Mode下运行</li>
<li>UITrackingRunLoopMode：界面跟踪Mode。用于追踪ScrollView的触摸滑动事件，保证界面滑动时不收其他Mode影响。</li>
<li>NSRunLoopCommonModes：这是一个占位用的Mode(综合以上两种模式)，不是一中真正的Mode。</li>
</ul>
<h5 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h5><ul>
<li>一个 RunLoop 包含若干个 Mode（模式），每个 Mode 又包含若干个Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定一个 Mode，这个Mode被称作 CurrentMode（当前模式）。如果需要切换 Mode，只能退出当前 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。</li>
</ul>
<h4 id="（四）CFRunLoopSourceRef"><a href="#（四）CFRunLoopSourceRef" class="headerlink" title="（四）CFRunLoopSourceRef"></a>（四）CFRunLoopSourceRef</h4><h5 id="1-按官方文档分类"><a href="#1-按官方文档分类" class="headerlink" title="1.按官方文档分类"></a>1.按官方文档分类</h5><ul>
<li>Port-Base Source：继续端口的，与其他线程进行交互</li>
<li>Custom Input Source</li>
<li>Cocoa Perform Selector Source</li>
</ul>
<h5 id="2-根据函数调用栈分类："><a href="#2-根据函数调用栈分类：" class="headerlink" title="2.根据函数调用栈分类："></a>2.根据函数调用栈分类：</h5><ul>
<li>Source0：非基于Port的。</li>
<li>Source1：基于Port的，通过内核和其他线程通信，接受、分发系统事件。</li>
<li>Source1接收到事件后，会交给Source0去处理</li>
</ul>
<h4 id="（五）CFRunLoopTimerRef"><a href="#（五）CFRunLoopTimerRef" class="headerlink" title="（五）CFRunLoopTimerRef"></a>（五）CFRunLoopTimerRef</h4><ul>
<li>CFRunLoopTimerRef基本上就是NSTimer，它受RunLoop的Mode影响。</li>
<li>GCD的定时器不受RunLoop的Mode影响。</li>
<li><p>① NSTimer默认加入RunLoop，且是NSDefaultRunLoopMode。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//调用了scheduledTimer返回的定时器，已经自动被添加到当前RunLoop中，默认是NSDefaultRunLoopMode</span><br><span class="line">NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(run) userInfo:nil repeats:YES];</span><br><span class="line"></span><br><span class="line">// 修改模式</span><br><span class="line">[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</span><br></pre></td></tr></table></figure>
</li>
<li><p>②三种模式分析</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">NSTimer *timer = [NSTimer timerWithTimeInterval:2.0 target:self selector:@selector(run) userInfo:nil repeats:YES];</span><br><span class="line">// 定时器只运行在NSDefaultRunLoopMode下，一旦RunLoop进入其他模式，这个定时器就不会工作</span><br><span class="line">[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];</span><br><span class="line"></span><br><span class="line">// 定时器只运行在UITrackingRunLoopMode下，一旦RunLoop进入其他模式，这个定时器就不会工作</span><br><span class="line">[[NSRunLoop currentRunLoop] addTimer:timer forMode:UITrackingRunLoopMode];</span><br><span class="line"></span><br><span class="line">// 定时器会跑在标记为common modes的模式下</span><br><span class="line">// 标记为common modes的模式：UITrackingRunLoopMode和NSDefaultRunLoopMode</span><br><span class="line">[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="（六）Oberserver（观察者）"><a href="#（六）Oberserver（观察者）" class="headerlink" title="（六）Oberserver（观察者）"></a>（六）Oberserver（观察者）</h4><ul>
<li>CFRunLoopObserverRef是观察者，能够监听RunLoop的状态改变</li>
<li>可以监听以下几个时间点：<br>CFRunLoopActivity的取值<br>kCFRunLoopEntry = (1UL &lt;&lt;0),<br>kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1),<br>kCFRunLoopBeforeSources = (1UL &lt;&lt; 2),<br>kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5),<br>kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6),<br>kCFRunLoopExit = (1UL &lt;&lt; 7),<br>kCFRunLoopAllActivities = 0x0FFFFFFFU</li>
</ul>
<h5 id="1-CFRunLoopObserverRef的使用"><a href="#1-CFRunLoopObserverRef的使用" class="headerlink" title="1.CFRunLoopObserverRef的使用"></a>1.CFRunLoopObserverRef的使用</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (void)observer&#123;</span><br><span class="line">// 1. 创建observer</span><br><span class="line">CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(CFAllocatorGetDefault(), kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) &#123;</span><br><span class="line">NSLog(@&quot;----监听到RunLoop状态发生改变---%zd&quot;, activity);</span><br><span class="line">&#125;);</span><br><span class="line">// 2. 添加观察者：监听RunLoop的状态</span><br><span class="line">CFRunLoopAddObserver(CFRunLoopGetCurrent(), observer, kCFRunLoopDefaultMode);</span><br><span class="line"></span><br><span class="line">// 3. 释放Observer</span><br><span class="line">CFRelease(observer);</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">CF的内存管理（Core Foundation）</span><br><span class="line">1.凡是带有Create、Copy、Retain等字眼的函数，创建出来的对象，都需要在最后做一次release</span><br><span class="line">* 比如CFRunLoopObserverCreate</span><br><span class="line">2.release函数：CFRelease(对象);</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<h4 id="（七）RunLoop整体处理逻辑"><a href="#（七）RunLoop整体处理逻辑" class="headerlink" title="（七）RunLoop整体处理逻辑"></a>（七）RunLoop整体处理逻辑</h4><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1foxdggdlw4j30n20hen3v.jpg" alt=""></p>

      
      <!-- 打赏 -->
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/04/RunLoop理论/" data-id="ck5i58g6a000awbbudy0z0c32"
        class="article-share-link">分享</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RunLoop/">RunLoop</a></li></ul>

    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-多线程的理解——队列与执行方式" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2018/03/03/多线程的理解——队列与执行方式/"
    >多线程的理解——队列与执行方式</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2018/03/03/多线程的理解——队列与执行方式/" class="article-date">
  <time datetime="2018-03-03T03:01:06.000Z" itemprop="datePublished">2018-03-03</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

      
      
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>多线程的理解——队列与执行方式</p>
<h4 id="1-队列类型"><a href="#1-队列类型" class="headerlink" title="1.队列类型"></a>1.队列类型</h4><ul>
<li>串行队列：顺序执行，一次执行一个任务。依次从队列中取出一个任务执行，必须一个任务执行完了，才能从队列里面取出下一个任务。</li>
<li>并行队列：任务是按照加入到队列中的顺序开始执行，但任务完成时的顺序是不确定的。</li>
<li>主队列：主线程中的串行队列（系统默认创建）。</li>
<li>全局队列：是全局的并行队列（系统默认创建。几乎等效于并行队列）。<br><br></li>
</ul>
<h4 id="2-执行方式"><a href="#2-执行方式" class="headerlink" title="2.执行方式"></a>2.执行方式</h4><ul>
<li>同步执行sync：不开新线程</li>
<li>异步执行async：开辟新线程<br><br></li>
</ul>
<h4 id="3-队列与执行方式"><a href="#3-队列与执行方式" class="headerlink" title="3.队列与执行方式"></a>3.队列与执行方式</h4><ul>
<li>串行队列同步执行：不开线程，在原来线程里面一个一个顺序执行</li>
<li>串行队列异步执行：开一条线程，在这个新线程里面一个一个顺序执行</li>
<li>并行队列同步执行：不开线程，在原来线程里面执行</li>
<li>并行队列异步执行：开多个线程，并发执行（不一定是一个一个）执行<br><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fozfz2vff0j313o0c8dm6.jpg" alt=""><br><br></li>
</ul>
<h4 id="4-死锁问题"><a href="#4-死锁问题" class="headerlink" title="4.死锁问题"></a>4.死锁问题</h4><p>死锁问题的理解，可参考：<a href="https://www.jianshu.com/p/bd574fd21da5" target="_blank" rel="noopener">《为什么dispatch_sync在主线程会死锁》</a></p>

      
      <!-- 打赏 -->
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/03/多线程的理解——队列与执行方式/" data-id="ck5i58g6p000vwbbuam4q9ew0"
        class="article-share-link">分享</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/多线程/">多线程</a></li></ul>

    </footer>

  </div>

  

  
  
  

  

</article>
    
  </article>
  

  
  <nav class="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        &copy;
        2018-2020
        GG266
      </li>
      <li>
        
          Powered by
        
        
        <a href="https://hexo.io" target="_blank">Hexo</a> Theme <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul class="list-inline">
      <li>
        
        
        <ul class="list-inline">
  <li>PV:<span id="busuanzi_value_page_pv"></span></li>
  <li>UV:<span id="busuanzi_value_site_uv"></span></li>
</ul>
        
      </li>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
    <div class="to_top">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>
      </div>
    </main>
    
      <aside class="sidebar">
        
        <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/avatar.svg" alt="GG266 Blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
      </aside>
      <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
      <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.justifiedGallery.min.js"></script>
<script src="/js/lazyload.min.js"></script>
<script src="/js/busuanzi-2.3.pure.min.js"></script>




<script>
  var ayerConfig = {
    mathjax: false
  }
</script>

<script src="/js/ayer.js"></script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">



<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>
  
  

  </div>
</body>

</html>